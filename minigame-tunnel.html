<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vite + TS</title>
  <style>
    .canvas-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 80vh;
    }
  </style>

</head>

<a href="./index.html">Go to IndexPage --> </a>

<body style="background-color: darkgrey; text-align: center;">
  <div id="app"></div>

  <script>var R = Object.defineProperty; var N = (l, e, o) => e in l ? R(l, e, { enumerable: !0, configurable: !0, writable: !0, value: o }) : l[e] = o; var s = (l, e, o) => N(l, typeof e != "symbol" ? e + "" : e, o); (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const a of i) if (a.type === "childList") for (const n of a.addedNodes) n.tagName === "LINK" && n.rel === "modulepreload" && r(n) }).observe(document, { childList: !0, subtree: !0 }); function o(i) { const a = {}; return i.integrity && (a.integrity = i.integrity), i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? a.credentials = "include" : i.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a } function r(i) { if (i.ep) return; i.ep = !0; const a = o(i); fetch(i.href, a) } })(); function D(l, e, o, r) { const i = document.createElement("canvas"); i.id = e, i.width = o, i.height = r; const a = document.getElementById(l), n = document.createElement("h1"); n.innerText = e, a.appendChild(n); const f = document.createElement("div"); return f.className = "canvas-container", f.appendChild(i), a.appendChild(f), a.appendChild(document.createElement("br")), i } class V { constructor(e) { s(this, "playerBlockCount", 1); s(this, "playerCoinCount", 0); s(this, "playerHealthMax"); s(this, "playerHealth"); s(this, "playerLevelReached", 1); this.playerHealthMax = e, this.playerHealth = e } getPlayerBlockCount() { return this.playerBlockCount } increasePlayerBlockCount() { this.playerBlockCount++ } decreasePlayerBlockCount() { return this.playerBlockCount > 0 ? (this.playerBlockCount--, !0) : !1 } getPlayerCoinCount() { return this.playerCoinCount } increasePlayerCoinCount() { this.playerCoinCount++ } decreasePlayerCoinCount(e) { return this.playerCoinCount >= e ? (this.playerCoinCount -= e, !0) : !1 } getPlayerHealth() { return this.playerHealth } decreasePlayerHealth(e, o) { const r = this.playerHealth - e; return this.playerHealth = r, r <= 0 ? !1 : (o.makeBlinkingPlayer(e), !0) } getPlayerLevelReached() { return this.playerLevelReached } increasePlayerLevelReached() { this.playerLevelReached++ } } var t = (l => (l[l.EMPTY = 0] = "EMPTY", l[l.PRESENT = 1] = "PRESENT", l[l.PLAYER = 2] = "PLAYER", l[l.UNBREAKABLE = 3] = "UNBREAKABLE", l[l.COLLECTABLE_COIN = 4] = "COLLECTABLE_COIN", l[l.GATE_OUT_CLOSED = 5] = "GATE_OUT_CLOSED", l[l.GATE_OUT_OPENED = 6] = "GATE_OUT_OPENED", l))(t || {}); const P = class P { constructor(e) { s(this, "informations", new V(P.healthMax)); s(this, "playerPosition"); s(this, "previousPosition"); s(this, "previousValue", t.EMPTY); s(this, "isBlinking", !1); this.playerPosition = e, this.previousPosition = { ...e } } static create(e) { return P.instance === null && (P.instance = new P(e)), P.instance } incrementPlayerBlockCount() { this.informations.increasePlayerBlockCount() } decrementPlayerBlockCount() { return this.informations.decreasePlayerBlockCount() } incrementPlayerCoinCount() { this.informations.increasePlayerCoinCount() } decreasePlayerCoinCount(e) { return this.informations.decreasePlayerCoinCount(e) } decreasePlayerHealth(e, o) { return this.informations.decreasePlayerHealth(e, o) } increasePlayerLevelReached() { this.informations.increasePlayerLevelReached() } getPlayerPosition() { return this.playerPosition } getPlayerPositionWith(e = 0, o = 0) { return { x: this.playerPosition.x + o, y: this.playerPosition.y + e } } getPositionOnTopOfPlayerPosition() { return this.getPlayerPositionWith(-1, 0) } getPositionOnDownOfPlayerPosition() { return this.getPlayerPositionWith(1, 0) } getPositionOnLeftOfPlayerPosition() { return this.getPlayerPositionWith(0, -1) } getPositionOnRightOfPlayerPosition() { return this.getPlayerPositionWith(0, 1) } setPlayerPosition(e) { this.playerPosition = e } getPlayerBlockCount() { return this.informations.getPlayerBlockCount() } getPlayerCoinCount() { return this.informations.getPlayerCoinCount() } getPlayerHealth() { return this.informations.getPlayerHealth() } getPreviousPosition() { return this.previousPosition } setPreviousPosition(e) { this.previousPosition.x = e.x, this.previousPosition.y = e.y } getPreviousValue() { return this.previousValue } setPreviousValue(e) { this.previousValue = e } getIsBlinking() { return this.isBlinking } setIsBlinking(e) { this.isBlinking = e } getLevelReached() { return this.informations.getPlayerLevelReached() } }; s(P, "VALUE", t.PLAYER), s(P, "healthMax", 10), s(P, "coinNeed", 5), s(P, "instance", null); let v = P; const h = class h { constructor(e, o, r) { s(this, "playerService"); s(this, "board"); s(this, "screenPosition", { x: 0, y: 0 }); s(this, "gateOutPosition"); this.playerService = r, this.board = this.createAnArraySquareGameBoard(e, o), this.putValueForAllArray(this.board, t.PRESENT), this.putRandomValueForAllArray(this.board, t.UNBREAKABLE, h.PROBABILITY_UNBREAKABLE_BLOCKS), this.putRandomValueForAllArray(this.board, t.COLLECTABLE_COIN, h.PROBABILITY_COLLECTABLE_COINS), this.putRandomValueForAllArray(this.board, t.EMPTY, h.PROBABILITY_EMPTY_CELLS), this.makeSafePlayerSpawnZone(this.board, r), this.gateOutPosition = { ...this.getPlayerPosition() } } static create(e, o, r) { return h.instance === null && (h.instance = new h(e, o, r)), h.instance } reCreateBoard() { this.board = this.createAnArraySquareGameBoard(Math.floor(Math.random() * 250 + 120), Math.floor(Math.random() * 250 + 120)), this.putValueForAllArray(this.board, t.PRESENT), this.putRandomValueForAllArray(this.board, t.UNBREAKABLE, h.PROBABILITY_UNBREAKABLE_BLOCKS), this.putRandomValueForAllArray(this.board, t.COLLECTABLE_COIN, h.PROBABILITY_COLLECTABLE_COINS), this.putRandomValueForAllArray(this.board, t.EMPTY, h.PROBABILITY_EMPTY_CELLS), this.makeSafePlayerSpawnZone(this.board, this.playerService), this.gateOutPosition = { ...this.getPlayerPosition() } } getValueFrom(e, o = { x: 0, y: 0 }) { return this.board[e.y + o.y][e.x + o.x] } setValueFrom(e, o, r = { x: 0, y: 0 }) { this.board[o.y + r.y][o.x + r.x] = e } moveScreenPosition(e) { switch (e) { case 0: this.screenPosition.y += 1; break; case 1: this.screenPosition.y -= 1; break; case 2: this.screenPosition.x += 1; break; case 3: this.screenPosition.x -= 1; break } } getGateOutPosition() { return this.gateOutPosition } createAnArraySquareGameBoard(e, o) { const r = []; for (let i = 0; i < o; i++) { const a = []; for (let n = 0; n < e; n++)a.push(0); r.push(a) } return r } putRandomValueForAllArray(e, o, r) { for (let i = 0; i < e.length; i++)for (let a = 0; a < e[0].length; a++)Math.random() <= r && (e[i][a] = o) } putValueForAllArray(e, o) { for (let r = 0; r < e.length; r++)for (let i = 0; i < e[0].length; i++)e[r][i] = o } getPlayerPosition(e = { x: 0, y: 0 }) { return this.playerService.getPlayerPositionWith(e.y, e.x) } setValueAtPosition(e, o) { this.board[e.y][e.x] = o } makeSafePlayerSpawnZone(e, o) { this.setValueAtPosition(this.getPlayerPosition({ y: -1, x: -1 }), t.EMPTY), this.setValueAtPosition(this.getPlayerPosition({ y: -1, x: 0 }), t.EMPTY), this.setValueAtPosition(this.getPlayerPosition({ y: -1, x: 1 }), t.EMPTY), this.setValueAtPosition(this.getPlayerPosition({ y: 0, x: -1 }), t.EMPTY), this.setValueAtPosition(this.getPlayerPosition({ y: 0, x: 1 }), t.EMPTY), this.setValueAtPosition(this.getPlayerPosition(), v.VALUE), this.setValueAtPosition(this.getPlayerPosition({ y: 1, x: 0 }), t.PRESENT), o.setPreviousValue(t.GATE_OUT_CLOSED), o.setPreviousPosition(this.getPlayerPosition()) } getBoard() { return this.board } getScreenPosition() { return this.screenPosition } setScreenPosition(e) { this.screenPosition = e } }; s(h, "instance", null), s(h, "PROBABILITY_UNBREAKABLE_BLOCKS", Math.random() * .4 + .01), s(h, "PROBABILITY_COLLECTABLE_COINS", Math.random() * .2 + .01), s(h, "PROBABILITY_EMPTY_CELLS", Math.random() * .3 + .01); let I = h; const y = class y { constructor(e, o, r) { s(this, "BLINKING_INTERVAL_TIME_MS", 150); s(this, "boardService"); s(this, "playerService"); s(this, "canvas"); s(this, "ctx"); s(this, "CELL_QUANTITY_X"); s(this, "CELL_QUANTITY_Y"); s(this, "CELL_SIZE"); this.canvas = e.canvas, this.ctx = this.canvas.getContext("2d"), this.CELL_QUANTITY_X = e.CELL_QUANTITY_X, this.CELL_QUANTITY_Y = e.CELL_QUANTITY_Y, this.CELL_SIZE = e.CELL_SIZE, this.boardService = o, this.playerService = r } static create(e, o, r) { return y.instance === null && (y.instance = new y(e, o, r)), y.instance } draw() { if (this.playerService.getPlayerHealth() <= 0) { this.drawGameOver(); return } this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.drawArray(this.ctx, this.boardService.getBoard()), this.ctx.strokeRect(0, 0, this.canvas.width, this.canvas.height) } makeBlinkingPlayer(e) { if (e <= 0 || this.playerService.getIsBlinking()) return; this.playerService.setIsBlinking(!0); let o = !1; const r = setInterval(() => { if (o = !o, o) { this.drawPlayerRed(); return } this.drawPlayerNormal() }, this.BLINKING_INTERVAL_TIME_MS); setTimeout(() => { clearInterval(r), this.drawPlayerNormal(), this.playerService.setIsBlinking(!1) }, 3 * this.BLINKING_INTERVAL_TIME_MS + 2 * this.BLINKING_INTERVAL_TIME_MS * (e - 1)) } drawArray(e, o) { for (let r = 0; r < this.CELL_QUANTITY_Y; r++)for (let i = 0; i < this.CELL_QUANTITY_X; i++) { if (r - this.boardService.getScreenPosition().y < 0 || r - this.boardService.getScreenPosition().y >= o.length || i - this.boardService.getScreenPosition().x < 0 || i - this.boardService.getScreenPosition().x >= o[0].length) continue; const a = o[r - this.boardService.getScreenPosition().y][i - this.boardService.getScreenPosition().x]; if (a === t.PLAYER) { e.fillStyle = this.getColor(a), e.fillRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeStyle = "black", e.strokeRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE); continue } if (a === t.UNBREAKABLE) { if (e.fillStyle = this.getColor(a), this.playerService.getPlayerPosition().y > 20) { let n = 255 - this.playerService.getPlayerPosition().y + 10; n <= 205 && (n = 205), e.fillStyle = "rgb(" + n + "," + n + "," + n + ")" } e.fillRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeStyle = "black", e.strokeRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.beginPath(), e.moveTo(i * this.CELL_SIZE, r * this.CELL_SIZE), e.lineTo((i + 1) * this.CELL_SIZE, (r + 1) * this.CELL_SIZE), e.stroke(), e.beginPath(), e.moveTo((i + 1) * this.CELL_SIZE, r * this.CELL_SIZE), e.lineTo(i * this.CELL_SIZE, (r + 1) * this.CELL_SIZE), e.stroke(); continue } if (a === t.COLLECTABLE_COIN) { if (e.fillStyle = this.getColor(a), this.playerService.getPlayerPosition().y > 20) { let n = 255 - this.playerService.getPlayerPosition().y + 10; n <= 205 && (n = 205), e.fillStyle = "rgb(" + n + "," + n + "," + n + ")" } e.fillRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeStyle = "black", e.strokeRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.beginPath(), e.arc((i + .5) * this.CELL_SIZE, (r + .5) * this.CELL_SIZE, this.CELL_SIZE * .45, 0, 2 * Math.PI), e.stroke(); continue } if (a === t.GATE_OUT_CLOSED) { e.fillStyle = this.getColor(a), e.strokeStyle = this.getTextColor(a), e.lineWidth = 6, e.fillRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeRect((i + .1) * this.CELL_SIZE, (r + .1) * this.CELL_SIZE, this.CELL_SIZE * .8, this.CELL_SIZE * .8), e.lineWidth = 1; continue } if (a === t.GATE_OUT_OPENED) { e.fillStyle = this.getColor(a), e.strokeStyle = this.getTextColor(a), e.lineWidth = 6, e.fillRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeRect((i + .1) * this.CELL_SIZE, (r + .1) * this.CELL_SIZE, this.CELL_SIZE * .8, this.CELL_SIZE * .8), e.lineWidth = 1; continue } if (e.fillStyle = this.getColor(a), this.playerService.getPlayerPosition().y > 20 && a === t.EMPTY) { let n = this.playerService.getPlayerPosition().y; n > 80 && (n = 80), e.fillStyle = "rgb(" + n + "," + n + "," + n + ")" } if (this.playerService.getPlayerPosition().y > 20 && a === t.PRESENT) { let n = 255 - this.playerService.getPlayerPosition().y; n <= 195 && (n = 195), e.fillStyle = "rgb(" + n + "," + n + "," + n + ")" } e.fillRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeStyle = "black", e.strokeRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE) } e.fillStyle = this.getColor(t.PLAYER), e.strokeStyle = "black"; for (let r = 0; r < this.CELL_QUANTITY_Y; r++)for (let i = 0; i < this.CELL_QUANTITY_X; i++)r === 0 || r === this.CELL_QUANTITY_Y - 1 ? (e.fillRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE)) : (i === 0 || i === this.CELL_QUANTITY_X - 1) && (e.fillRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeRect(i * this.CELL_SIZE, r * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE)); e.fillStyle = this.getColor(t.PLAYER), e.strokeStyle = "black", e.fillRect(0, 0, 2 * this.CELL_SIZE, 2 * this.CELL_SIZE), e.strokeRect(0, 0, 2 * this.CELL_SIZE, 2 * this.CELL_SIZE), e.fillStyle = "white", e.font = Math.floor(this.CELL_SIZE * .3) + "px Arial", e.fillText(`x: ${this.playerService.getPlayerPosition().x} | y: ${this.playerService.getPlayerPosition().y}`, this.CELL_SIZE * .1, this.CELL_SIZE * .3, 2 * this.CELL_SIZE), e.fillText(`blocks: ${this.playerService.getPlayerBlockCount()}`, this.CELL_SIZE * .1, this.CELL_SIZE * .8, 2 * this.CELL_SIZE), e.fillText(`coins: ${this.playerService.getPlayerCoinCount()} / ${v.coinNeed}`, this.CELL_SIZE * .1, this.CELL_SIZE * 1.3, 2 * this.CELL_SIZE), e.fillText(`health: ${this.playerService.getPlayerHealth()} / ${v.healthMax}`, this.CELL_SIZE * .1, this.CELL_SIZE * 1.8, 2 * this.CELL_SIZE), e.fillStyle = this.getColor(t.PLAYER), e.strokeStyle = "black", e.fillRect((this.CELL_QUANTITY_X - 3) * this.CELL_SIZE, 0, 3 * this.CELL_SIZE, this.CELL_SIZE), e.strokeRect((this.CELL_QUANTITY_X - 3) * this.CELL_SIZE, 0, 3 * this.CELL_SIZE, this.CELL_SIZE), e.fillStyle = "white", e.font = Math.floor(this.CELL_SIZE * .3) + "px Arial", e.fillText(`Level : ${this.playerService.getLevelReached()}`, (this.CELL_QUANTITY_X - 3) * this.CELL_SIZE + this.CELL_SIZE * .2, this.CELL_SIZE * .4, 2 * this.CELL_SIZE) } getColor(e) { switch (e) { case t.PRESENT: return "white"; case t.PLAYER: return "grey"; case t.UNBREAKABLE: return "white"; case t.COLLECTABLE_COIN: return "white"; case t.GATE_OUT_CLOSED: return "lightgrey"; case t.GATE_OUT_OPENED: return "grey"; default: return "black" } } getTextColor(e) { switch (e) { case t.PRESENT: return "black"; case t.PLAYER: return "white"; case t.UNBREAKABLE: return "black"; case t.COLLECTABLE_COIN: return "black"; case t.GATE_OUT_CLOSED: return "grey"; case t.GATE_OUT_OPENED: return "white"; default: return "white" } } drawPlayerRed() { this.ctx.fillStyle = "red", this.ctx.strokeStyle = "white", this.ctx.fillRect(Math.floor(this.CELL_QUANTITY_X / 2) * this.CELL_SIZE, Math.floor(this.CELL_QUANTITY_Y / 2) * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), this.ctx.strokeRect(Math.floor(this.CELL_QUANTITY_X / 2) * this.CELL_SIZE, Math.floor(this.CELL_QUANTITY_Y / 2) * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE) } drawPlayerNormal() { this.ctx.fillStyle = this.getColor(t.PLAYER), this.ctx.strokeStyle = "black", this.ctx.fillRect(Math.floor(this.CELL_QUANTITY_X / 2) * this.CELL_SIZE, Math.floor(this.CELL_QUANTITY_Y / 2) * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), this.ctx.strokeRect(Math.floor(this.CELL_QUANTITY_X / 2) * this.CELL_SIZE, Math.floor(this.CELL_QUANTITY_Y / 2) * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE) } drawGameOver() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.ctx.fillStyle = "black", this.ctx.font = Math.floor(this.CELL_SIZE * 1.5) + "px Arial", this.ctx.fillText("GAME OVER", this.CELL_SIZE * 2, this.CELL_SIZE * 6, this.CELL_SIZE * 11); const e = this.playerService.getLevelReached(); this.ctx.fillText("LevelReached : " + e, this.CELL_SIZE * 1, this.CELL_SIZE * 8, this.CELL_SIZE * 11) } }; s(y, "instance", null); let p = y; class M { constructor(e, o, r, i) { s(this, "canvas"); s(this, "CELL_QUANTITY_X"); s(this, "CELL_QUANTITY_Y"); s(this, "CELL_SIZE"); this.canvas = e, this.CELL_QUANTITY_X = o, this.CELL_QUANTITY_Y = r, this.CELL_SIZE = i } } const C = class C { static mineABlock(e) { Math.random() <= C.CHANCE_TO_GET_BLOCK_FROM_MINING && e.incrementPlayerBlockCount() } static destroyBlockCollectable(e, o) { e.incrementPlayerCoinCount(), e.getPlayerCoinCount() >= v.coinNeed && o.setValueFrom(t.GATE_OUT_OPENED, o.getGateOutPosition()) } static fallingDownRecursiveAction(e, o) { C.actionToDoWhenFallingDown(e), e.emptyDownCount--, e.emptyDownCount <= 0 ? (e.arrowKeysActive = !0, e.emptyDownCount = 1, e.rulesUnbreakableBlock.whenIsAnUnbreakableFallingDownOnPlayer(o), e.drawService.draw()) : setTimeout(() => C.fallingDownRecursiveAction(e, o), 100) } static actionToDoWhenFallingDown(e) { e.boardService.getScreenPosition().y -= 1, e.boardService.getBoard()[e.playerService.getPlayerPosition().y][e.playerService.getPlayerPosition().x] = e.playerService.getPreviousValue(), e.playerService.setPreviousPosition(e.playerService.getPlayerPosition()), e.playerService.getPlayerPosition().y += 1, e.playerService.setPreviousValue(e.boardService.getBoard()[e.playerService.getPlayerPosition().y][e.playerService.getPlayerPosition().x]), e.boardService.getBoard()[e.playerService.getPlayerPosition().y][e.playerService.getPlayerPosition().x] = v.VALUE, e.rulesUnbreakableBlock.whenPlayerSucceedToMoveDown(), e.drawService.draw() } }; s(C, "CHANCE_TO_GET_BLOCK_FROM_MINING", .5); let c = C; const S = class S { constructor(e) { s(this, "eventService"); this.eventService = e } static create(e) { return S.instance === null && (S.instance = new S(e)), S.instance } whenIsNotAbleToMoveUp() { return !this.eventService.arrowKeysActive || this.getPlayerPosY() === 0 || this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] === t.UNBREAKABLE } whenValueIsPresentOnUp() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] === t.PRESENT ? (this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] = t.EMPTY, c.mineABlock(this.eventService.playerService), this.eventService.rulesUnbreakableBlock.whenPlayerSucceedToDigUp(), this.eventService.drawService.draw(), !0) : !1 } whenValueIsCollectableOnUp() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] === t.COLLECTABLE_COIN ? (this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] = t.EMPTY, c.destroyBlockCollectable(this.eventService.playerService, this.eventService.boardService), this.eventService.rulesUnbreakableBlock.whenPlayerSucceedToDigUp(), this.eventService.drawService.draw(), !0) : !1 } whenValueIsEmptyOnUp() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] !== t.EMPTY || this.eventService.playerService.getPreviousValue() === t.GATE_OUT_CLOSED || this.eventService.playerService.getPreviousValue() === t.GATE_OUT_OPENED || this.eventService.playerService.getPlayerBlockCount() <= 0 ? !1 : (this.eventService.playerService.decrementPlayerBlockCount(), this.movePlayerUp(), !0) } whenValueIsGateOutClosedOnUp() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] !== t.GATE_OUT_CLOSED || this.eventService.playerService.getPlayerBlockCount() <= 0 ? !1 : (this.eventService.playerService.decrementPlayerBlockCount(), this.movePlayerUp(), !0) } whenValueIsGateOutOpenedOnUp() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] !== t.GATE_OUT_OPENED || this.eventService.playerService.getPlayerBlockCount() <= 0 ? !1 : (this.eventService.playerService.decrementPlayerBlockCount(), this.movePlayerUp(), !0) } whenValueOnPlayerPositionIsGateClosed() { return this.eventService.playerService.getPreviousValue() !== t.GATE_OUT_CLOSED ? !1 : (console.log("GateIsClosed"), !0) } whenValueOnPlayerPositionIsGateOpened() { return this.eventService.playerService.getPreviousValue() !== t.GATE_OUT_OPENED ? !1 : (console.log("GateIsOpened go to new level :)"), this.LevelUp(), !0) } getPlayerPosY() { return this.eventService.playerService.getPlayerPosition().y } getPlayerPosX() { return this.eventService.playerService.getPlayerPosition().x } movePlayerUp() { this.eventService.playerService.setPreviousValue(t.PRESENT), this.eventService.boardService.getScreenPosition().y += 1, this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()] = this.eventService.playerService.getPreviousValue(), this.eventService.playerService.setPreviousPosition(this.eventService.playerService.getPlayerPosition()), this.eventService.playerService.getPlayerPosition().y -= 1, this.eventService.playerService.setPreviousValue(this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()]), this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()] = v.VALUE, this.eventService.drawService.draw() } LevelUp() { this.eventService.playerService.decreasePlayerCoinCount(v.coinNeed), v.coinNeed += 5, this.eventService.playerService.increasePlayerLevelReached(), this.eventService.boardService.reCreateBoard(), this.eventService.drawService.draw() } }; s(S, "instance", null); let w = S; const u = class u { constructor(e) { s(this, "eventService"); this.eventService = e } static create(e) { return u.instance === null && (u.instance = new u(e)), u.instance } whenIsNotAbleToMoveDown() { return !this.eventService.arrowKeysActive || this.getPlayerPosY() === this.eventService.boardService.getBoard().length - 1 || this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.UNBREAKABLE } whenValueIsPresentOnDown() { if (this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.PRESENT) { for (this.eventService.arrowKeysActive = !1, this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] = t.EMPTY, c.mineABlock(this.eventService.playerService); this.getPlayerPosY() + this.eventService.emptyDownCount + 1 <= this.eventService.boardService.getBoard().length - 1 && this.eventService.boardService.getBoard()[this.getPlayerPosY() + this.eventService.emptyDownCount + 1][this.getPlayerPosX()] === t.EMPTY;)this.eventService.emptyDownCount++; const e = this.eventService.emptyDownCount; return setTimeout(() => c.fallingDownRecursiveAction(this.eventService, e), 100), !0 } return !1 } whenValueIsCollectableOnDown() { if (this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.COLLECTABLE_COIN) { for (this.eventService.arrowKeysActive = !1, this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] = t.EMPTY, c.destroyBlockCollectable(this.eventService.playerService, this.eventService.boardService); this.getPlayerPosY() + this.eventService.emptyDownCount + 1 <= this.eventService.boardService.getBoard().length - 1 && this.eventService.boardService.getBoard()[this.getPlayerPosY() + this.eventService.emptyDownCount + 1][this.getPlayerPosX()] === t.EMPTY;)this.eventService.emptyDownCount++; const e = this.eventService.emptyDownCount; return setTimeout(() => c.fallingDownRecursiveAction(this.eventService, e), 100), !0 } return !1 } whenValueIsGateOutClosedOnDown() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.GATE_OUT_CLOSED ? (this.movePlayerDown(), !0) : !1 } whenValueIsGateOutOpenedOnDown() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.GATE_OUT_OPENED ? (this.movePlayerDown(), !0) : !1 } whenValueIsEmptyOnDown() { if (this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.EMPTY) { for (this.eventService.arrowKeysActive = !1; this.getPlayerPosY() + this.eventService.emptyDownCount + 1 <= this.eventService.boardService.getBoard().length - 1 && this.eventService.boardService.getBoard()[this.eventService.playerService.getPlayerPosition().y + this.eventService.emptyDownCount + 1][this.eventService.playerService.getPlayerPosition().x] === t.EMPTY;)this.eventService.emptyDownCount++; const e = this.eventService.emptyDownCount; return setTimeout(() => c.fallingDownRecursiveAction(this.eventService, e), 100), !0 } return !1 } getPlayerPosY() { return this.eventService.playerService.getPlayerPosition().y } getPlayerPosX() { return this.eventService.playerService.getPlayerPosition().x } movePlayerDown() { this.eventService.boardService.getScreenPosition().y -= 1, this.eventService.boardService.setValueFrom(this.eventService.playerService.getPreviousValue(), this.eventService.playerService.getPlayerPosition()), this.eventService.playerService.setPreviousPosition(this.eventService.playerService.getPlayerPosition()), this.eventService.playerService.getPlayerPosition().y += 1, this.eventService.playerService.setPreviousValue(this.eventService.boardService.getValueFrom(this.eventService.playerService.getPlayerPosition())), this.eventService.boardService.setValueFrom(t.PLAYER, this.eventService.playerService.getPlayerPosition()), this.eventService.drawService.draw() } }; s(u, "instance", null); let O = u; const E = class E { constructor(e) { s(this, "eventService"); this.eventService = e } static create(e) { return E.instance === null && (E.instance = new E(e)), E.instance } whenIsNotAbleToMoveLeft() { return !this.eventService.arrowKeysActive || this.eventService.playerService.getPlayerPosition().x === 0 || this.getPlayerPosX() > 0 && this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] === t.UNBREAKABLE } whenValueIsPresentOnLeft() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] === t.PRESENT ? (this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] = t.EMPTY, c.mineABlock(this.eventService.playerService), this.eventService.drawService.draw(), !0) : !1 } whenValueIsCollectableOnLeft() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] === t.COLLECTABLE_COIN ? (this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] = t.EMPTY, c.destroyBlockCollectable(this.eventService.playerService, this.eventService.boardService), this.eventService.drawService.draw(), !0) : !1 } whenValueIsGateOutClosedOnLeft() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] === t.GATE_OUT_CLOSED ? (this.movePlayerLeft(), !0) : !1 } whenValueIsGateOutOpenedOnLeft() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] === t.GATE_OUT_OPENED ? (this.movePlayerLeft(), !0) : !1 } whenValueIsEmptyOnLeft() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] === t.EMPTY ? (this.movePlayerLeft(), this.checkIfPlayerIsFallingDown(), !0) : !1 } getPlayerPosY() { return this.eventService.playerService.getPlayerPosition().y } getPlayerPosX() { return this.eventService.playerService.getPlayerPosition().x } movePlayerLeft() { this.eventService.boardService.getScreenPosition().x += 1, this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()] = this.eventService.playerService.getPreviousValue(), this.eventService.playerService.setPreviousPosition(this.eventService.playerService.getPlayerPosition()), this.eventService.playerService.getPlayerPosition().x -= 1, this.eventService.playerService.setPreviousValue(this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()]), this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()] = v.VALUE, this.eventService.rulesUnbreakableBlock.whenPlayerSucceedToMoveLeft(), this.eventService.drawService.draw() } checkIfPlayerIsFallingDown() { if (!(this.getPlayerPosY() >= this.eventService.boardService.getBoard().length - 1) && this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.EMPTY) { for (this.eventService.arrowKeysActive = !1; this.getPlayerPosY() + this.eventService.emptyDownCount + 1 <= this.eventService.boardService.getBoard().length - 1 && this.eventService.boardService.getBoard()[this.getPlayerPosY() + this.eventService.emptyDownCount + 1][this.getPlayerPosX()] === t.EMPTY;)this.eventService.emptyDownCount++; const e = this.eventService.emptyDownCount; setTimeout(() => c.fallingDownRecursiveAction(this.eventService, e), 100) } } }; s(E, "instance", null); let A = E; const L = class L { constructor(e) { s(this, "eventService"); this.eventService = e } static create(e) { return L.instance === null && (L.instance = new L(e)), L.instance } whenIsNotAbleToMoveRight() { return !this.eventService.arrowKeysActive || this.getPlayerPosX() === this.eventService.boardService.getBoard()[0].length - 1 || this.getPlayerPosX() > 0 && this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] === t.UNBREAKABLE } whenValueIsPresentOnRight() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] === t.PRESENT ? (this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] = t.EMPTY, c.mineABlock(this.eventService.playerService), this.eventService.drawService.draw(), !0) : !1 } whenValueIsCollectableOnRight() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] === t.COLLECTABLE_COIN ? (this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] = t.EMPTY, c.destroyBlockCollectable(this.eventService.playerService, this.eventService.boardService), this.eventService.drawService.draw(), !0) : !1 } whenValueIsGateOutClosedOnRight() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] === t.GATE_OUT_CLOSED ? (this.movePlayerRight(), !0) : !1 } whenValueIsGateOutOpenedOnRight() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] === t.GATE_OUT_OPENED ? (this.movePlayerRight(), !0) : !1 } whenValueIsEmptyOnRight() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] === t.EMPTY ? (this.movePlayerRight(), this.checkIfPlayerIsFallingDown(), !0) : !1 } getPlayerPosY() { return this.eventService.playerService.getPlayerPosition().y } getPlayerPosX() { return this.eventService.playerService.getPlayerPosition().x } movePlayerRight() { this.eventService.boardService.getScreenPosition().x -= 1, this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()] = this.eventService.playerService.getPreviousValue(), this.eventService.playerService.setPreviousPosition(this.eventService.playerService.getPlayerPosition()), this.eventService.playerService.getPlayerPosition().x += 1, this.eventService.playerService.setPreviousValue(this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()]), this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()] = v.VALUE, this.eventService.rulesUnbreakableBlock.whenPlayerSucceedToMoveRight(), this.eventService.drawService.draw() } checkIfPlayerIsFallingDown() { if (!(this.getPlayerPosY() >= this.eventService.boardService.getBoard().length - 1) && this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.EMPTY) { for (this.eventService.arrowKeysActive = !1; this.getPlayerPosY() + this.eventService.emptyDownCount + 1 <= this.eventService.boardService.getBoard().length - 1 && this.eventService.boardService.getBoard()[this.getPlayerPosY() + this.eventService.emptyDownCount + 1][this.getPlayerPosX()] === t.EMPTY;)this.eventService.emptyDownCount++; const e = this.eventService.emptyDownCount; setTimeout(() => c.fallingDownRecursiveAction(this.eventService, e), 100) } } }; s(L, "instance", null); let T = L; const g = class g { constructor(e) { s(this, "eventService"); s(this, "playerPreviousPosition", { x: 0, y: 0 }); s(this, "blockUpponPlayerPreviousPosition", { x: 0, y: 0 }); s(this, "playerPosition", { x: 0, y: 0 }); s(this, "blockUpponPlayerPosition", { x: 0, y: 0 }); this.eventService = e } static create(e) { return g.instance === null && (g.instance = new g(e)), g.instance } whenPlayerSucceedToMoveLeft() { this.IsUnbreakableBlockOnTopOfPreviousPlayerPosition() && this.unbreakableBlockGoesOnPreviousPlayerPosition() } whenPlayerSucceedToMoveRight() { this.IsUnbreakableBlockOnTopOfPreviousPlayerPosition() && this.unbreakableBlockGoesOnPreviousPlayerPosition() } whenPlayerSucceedToMoveDown() { this.IsUnbreakableBlockOnTopOfPreviousPlayerPosition() && this.unbreakableBlockGoesOnPreviousPlayerPosition() } whenIsAnUnbreakableFallingDownOnPlayer(e) { this.IsUnbreakableBlockOnTopOfActualPlayerPosition() && this.eventService.playerService.decreasePlayerHealth(e, this.eventService.drawService) === !1 && this.gameOver() } whenPlayerSucceedToDigUp() { if (this.playerPosition.y <= 1) return; const e = { x: this.playerPosition.x, y: this.playerPosition.y - 2 }; this.IsUnbreakableBlockOnPosition(e) && (this.unbreakableBlockGoesDownFromPosition(e), this.eventService.playerService.decreasePlayerHealth(1, this.eventService.drawService) === !1 && this.gameOver()) } IsUnbreakableBlockOnTopOfPreviousPlayerPosition() { return this.playerPreviousPosition = this.eventService.playerService.getPreviousPosition(), this.playerPreviousPosition.y < 1 ? !1 : (this.blockUpponPlayerPreviousPosition = { x: this.playerPreviousPosition.x, y: this.playerPreviousPosition.y - 1 }, this.eventService.boardService.getValueFrom(this.blockUpponPlayerPreviousPosition) === t.UNBREAKABLE) } IsUnbreakableBlockOnTopOfActualPlayerPosition() { return this.playerPosition = this.eventService.playerService.getPlayerPosition(), this.playerPosition.y < 1 ? !1 : (this.blockUpponPlayerPosition = { x: this.playerPosition.x, y: this.playerPosition.y - 1 }, this.eventService.boardService.getValueFrom(this.blockUpponPlayerPosition) === t.UNBREAKABLE) } unbreakableBlockGoesOnPreviousPlayerPosition() { this.eventService.boardService.setValueFrom(t.EMPTY, this.blockUpponPlayerPreviousPosition), this.eventService.boardService.setValueFrom(t.UNBREAKABLE, this.playerPreviousPosition) } IsUnbreakableBlockOnPosition(e) { return this.eventService.boardService.getValueFrom(e) === t.UNBREAKABLE } unbreakableBlockGoesDownFromPosition(e) { e.y >= this.eventService.boardService.getBoard().length - 1 || (this.eventService.boardService.setValueFrom(t.EMPTY, e), this.eventService.boardService.setValueFrom(t.UNBREAKABLE, e, { x: 0, y: 1 })) } gameOver() { this.eventService.arrowKeysActive = !1, console.log("GAME OVER") } }; s(g, "instance", null); let _ = g; const d = class d { constructor(e, o, r, i) { s(this, "boardService"); s(this, "playerService"); s(this, "drawService"); s(this, "rulesOnArrowUp", w.create(this)); s(this, "rulesOnArrowDown", O.create(this)); s(this, "rulesOnArrowLeft", A.create(this)); s(this, "rulesOnArrowRight", T.create(this)); s(this, "rulesUnbreakableBlock", _.create(this)); s(this, "arrowKeysActive", !0); s(this, "emptyDownCount", 1); s(this, "window"); s(this, "keyBoardEventListener"); this.window = e, this.drawService = o, this.boardService = r, this.playerService = i, this.keyBoardEventListener = a => { this.handleKeyBoardEvent(a) } } static create(e, o, r, i) { return d.instance === null && (d.instance = new d(e, o, r, i)), d.instance } addEventListenerToWindow() { window.addEventListener("keydown", this.keyBoardEventListener) } removeEventListenerFromWindow() { window.removeEventListener("keydown", this.keyBoardEventListener) } handleKeyBoardEvent(e) { e.key === "ArrowUp" ? this.actionsOnArrowUp(e) : e.key === "ArrowDown" ? this.actionsOnArrowDown(e) : e.key === "ArrowLeft" ? this.actionsOnArrowLeft(e) : e.key === "ArrowRight" && this.actionsOnArrowRight(e) } actionsOnArrowUp(e) { switch (e.preventDefault(), !0) { case this.rulesOnArrowUp.whenValueOnPlayerPositionIsGateClosed(): break; case this.rulesOnArrowUp.whenValueOnPlayerPositionIsGateOpened(): break; case this.rulesOnArrowUp.whenIsNotAbleToMoveUp(): break; case this.rulesOnArrowUp.whenValueIsPresentOnUp(): break; case this.rulesOnArrowUp.whenValueIsCollectableOnUp(): break; case this.rulesOnArrowUp.whenValueIsGateOutClosedOnUp(): break; case this.rulesOnArrowUp.whenValueIsGateOutOpenedOnUp(): break; case this.rulesOnArrowUp.whenValueIsEmptyOnUp(): break } } actionsOnArrowDown(e) { switch (e.preventDefault(), !0) { case this.rulesOnArrowDown.whenIsNotAbleToMoveDown(): break; case this.rulesOnArrowDown.whenValueIsPresentOnDown(): break; case this.rulesOnArrowDown.whenValueIsCollectableOnDown(): break; case this.rulesOnArrowDown.whenValueIsGateOutClosedOnDown(): break; case this.rulesOnArrowDown.whenValueIsGateOutOpenedOnDown(): break; case this.rulesOnArrowDown.whenValueIsEmptyOnDown(): break } } actionsOnArrowLeft(e) { switch (e.preventDefault(), !0) { case this.rulesOnArrowLeft.whenIsNotAbleToMoveLeft(): break; case this.rulesOnArrowLeft.whenValueIsPresentOnLeft(): break; case this.rulesOnArrowLeft.whenValueIsCollectableOnLeft(): break; case this.rulesOnArrowLeft.whenValueIsGateOutClosedOnLeft(): break; case this.rulesOnArrowLeft.whenValueIsGateOutOpenedOnLeft(): break; case this.rulesOnArrowLeft.whenValueIsEmptyOnLeft(): break } } actionsOnArrowRight(e) { switch (e.preventDefault(), !0) { case this.rulesOnArrowRight.whenIsNotAbleToMoveRight(): break; case this.rulesOnArrowRight.whenValueIsPresentOnRight(): break; case this.rulesOnArrowRight.whenValueIsCollectableOnRight(): break; case this.rulesOnArrowRight.whenValueIsGateOutClosedOnRight(): break; case this.rulesOnArrowRight.whenValueIsGateOutOpenedOnRight(): break; case this.rulesOnArrowRight.whenValueIsEmptyOnRight(): break } } }; s(d, "instance", null); let b = d; const B = 15, k = 11, Y = v.create({ x: Math.floor(B / 2), y: Math.floor(k / 2) }), X = 32, G = 32, U = I.create(X, G, Y), m = 50, K = m * B, F = m * k, x = D("app", "MiniGameTunnel", K, F), Q = new M(x, B, k, m), Z = p.create(Q, U, Y), H = b.create(window, Z, U, Y); H.addEventListenerToWindow(); Z.draw();
  </script>
</body>

</html>
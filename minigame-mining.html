<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vite + TS</title>
  <style>
    .canvas-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 80vh;
    }
  </style>

</head>

<a href="./index.html">Go to IndexPage --> </a>

<body style="background-color: darkgrey; text-align: center;">
  <div id="app"></div>


  <script>var D = Object.defineProperty; var N = (l, e, o) => e in l ? D(l, e, { enumerable: !0, configurable: !0, writable: !0, value: o }) : l[e] = o; var i = (l, e, o) => N(l, typeof e != "symbol" ? e + "" : e, o); (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) s(r); new MutationObserver(r => { for (const n of r) if (n.type === "childList") for (const a of n.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && s(a) }).observe(document, { childList: !0, subtree: !0 }); function o(r) { const n = {}; return r.integrity && (n.integrity = r.integrity), r.referrerPolicy && (n.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? n.credentials = "include" : r.crossOrigin === "anonymous" ? n.credentials = "omit" : n.credentials = "same-origin", n } function s(r) { if (r.ep) return; r.ep = !0; const n = o(r); fetch(r.href, n) } })(); function M(l, e, o, s) { const r = document.createElement("canvas"); r.id = e, r.width = o, r.height = s; const n = document.getElementById(l), a = document.createElement("h1"); a.innerText = e, n.appendChild(a); const f = document.createElement("div"); return f.className = "canvas-container", f.appendChild(r), n.appendChild(f), n.appendChild(document.createElement("br")), r } class V { constructor(e) { i(this, "playerBlockCount", 1); i(this, "playerCoinCount", 0); i(this, "playerHealthMax"); i(this, "playerHealth"); i(this, "playerLevelReached", 1); this.playerHealthMax = e, this.playerHealth = e } getPlayerBlockCount() { return this.playerBlockCount } increasePlayerBlockCount() { this.playerBlockCount++ } decreasePlayerBlockCount() { return this.playerBlockCount > 0 ? (this.playerBlockCount--, !0) : !1 } getPlayerCoinCount() { return this.playerCoinCount } increasePlayerCoinCount() { this.playerCoinCount++ } decreasePlayerCoinCount(e) { return this.playerCoinCount >= e ? (this.playerCoinCount -= e, !0) : !1 } getPlayerHealth() { return this.playerHealth } decreasePlayerHealth(e, o) { const s = this.playerHealth - e; return this.playerHealth = s, s <= 0 ? !1 : (o.makeBlinkingPlayer(e), !0) } getPlayerLevelReached() { return this.playerLevelReached } increasePlayerLevelReached() { this.playerLevelReached++ } } var t = (l => (l[l.EMPTY = 0] = "EMPTY", l[l.PRESENT = 1] = "PRESENT", l[l.PLAYER = 2] = "PLAYER", l[l.UNBREAKABLE = 3] = "UNBREAKABLE", l[l.COLLECTABLE_COIN = 4] = "COLLECTABLE_COIN", l[l.GATE_OUT_CLOSED = 5] = "GATE_OUT_CLOSED", l[l.GATE_OUT_OPENED = 6] = "GATE_OUT_OPENED", l))(t || {}); const u = class u { constructor(e) { i(this, "informations", new V(u.healthMax)); i(this, "playerPosition"); i(this, "previousPosition"); i(this, "previousValue", t.EMPTY); i(this, "isBlinking", !1); this.playerPosition = e, this.previousPosition = { ...e } } static create(e) { return u.instance === null && (u.instance = new u(e)), u.instance } incrementPlayerBlockCount() { this.informations.increasePlayerBlockCount() } decrementPlayerBlockCount() { return this.informations.decreasePlayerBlockCount() } incrementPlayerCoinCount() { this.informations.increasePlayerCoinCount() } decreasePlayerCoinCount(e) { return this.informations.decreasePlayerCoinCount(e) } decreasePlayerHealth(e, o) { return this.informations.decreasePlayerHealth(e, o) } increasePlayerLevelReached() { this.informations.increasePlayerLevelReached() } getPlayerPosition() { return this.playerPosition } getPlayerPositionWith(e = 0, o = 0) { return { x: this.playerPosition.x + o, y: this.playerPosition.y + e } } getPositionOnTopOfPlayerPosition() { return this.getPlayerPositionWith(-1, 0) } getPositionOnDownOfPlayerPosition() { return this.getPlayerPositionWith(1, 0) } getPositionOnLeftOfPlayerPosition() { return this.getPlayerPositionWith(0, -1) } getPositionOnRightOfPlayerPosition() { return this.getPlayerPositionWith(0, 1) } setPlayerPosition(e) { this.playerPosition = e } getPlayerBlockCount() { return this.informations.getPlayerBlockCount() } getPlayerCoinCount() { return this.informations.getPlayerCoinCount() } getPlayerHealth() { return this.informations.getPlayerHealth() } getPreviousPosition() { return this.previousPosition } setPreviousPosition(e) { this.previousPosition.x = e.x, this.previousPosition.y = e.y } getPreviousValue() { return this.previousValue } setPreviousValue(e) { this.previousValue = e } getIsBlinking() { return this.isBlinking } setIsBlinking(e) { this.isBlinking = e } getLevelReached() { return this.informations.getPlayerLevelReached() } }; i(u, "VALUE", t.PLAYER), i(u, "healthMax", 10), i(u, "coinNeed", 5), i(u, "instance", null); let v = u; const h = class h { constructor(e, o, s) { i(this, "playerService"); i(this, "board"); i(this, "screenPosition", { x: 0, y: 0 }); i(this, "gateOutPosition"); this.playerService = s, this.board = this.createAnArraySquareGameBoard(e, o), this.putValueForAllArray(this.board, t.PRESENT), this.putRandomValueForAllArray(this.board, t.UNBREAKABLE, h.PROBABILITY_UNBREAKABLE_BLOCKS), this.putRandomValueForAllArray(this.board, t.COLLECTABLE_COIN, h.PROBABILITY_COLLECTABLE_COINS), this.putRandomValueForAllArray(this.board, t.EMPTY, h.PROBABILITY_EMPTY_CELLS), this.makeSafePlayerSpawnZone(this.board, s), this.gateOutPosition = { ...this.getPlayerPosition() } } static create(e, o, s) { return h.instance === null && (h.instance = new h(e, o, s)), h.instance } reCreateBoard() { this.board = this.createAnArraySquareGameBoard(Math.floor(Math.random() * 250 + 120), Math.floor(Math.random() * 250 + 120)), this.putValueForAllArray(this.board, t.PRESENT), this.putRandomValueForAllArray(this.board, t.UNBREAKABLE, h.PROBABILITY_UNBREAKABLE_BLOCKS), this.putRandomValueForAllArray(this.board, t.COLLECTABLE_COIN, h.PROBABILITY_COLLECTABLE_COINS), this.putRandomValueForAllArray(this.board, t.EMPTY, h.PROBABILITY_EMPTY_CELLS), this.makeSafePlayerSpawnZone(this.board, this.playerService), this.gateOutPosition = { ...this.getPlayerPosition() } } getValueFrom(e, o = { x: 0, y: 0 }) { return this.board[e.y + o.y][e.x + o.x] } setValueFrom(e, o, s = { x: 0, y: 0 }) { this.board[o.y + s.y][o.x + s.x] = e } moveScreenPosition(e) { switch (e) { case 0: this.screenPosition.y += 1; break; case 1: this.screenPosition.y -= 1; break; case 2: this.screenPosition.x += 1; break; case 3: this.screenPosition.x -= 1; break } } getGateOutPosition() { return this.gateOutPosition } createAnArraySquareGameBoard(e, o) { const s = []; for (let r = 0; r < o; r++) { const n = []; for (let a = 0; a < e; a++)n.push(0); s.push(n) } return s } putRandomValueForAllArray(e, o, s) { for (let r = 0; r < e.length; r++)for (let n = 0; n < e[0].length; n++)Math.random() <= s && (e[r][n] = o) } putValueForAllArray(e, o) { for (let s = 0; s < e.length; s++)for (let r = 0; r < e[0].length; r++)e[s][r] = o } getPlayerPosition(e = { x: 0, y: 0 }) { return this.playerService.getPlayerPositionWith(e.y, e.x) } setValueAtPosition(e, o) { this.board[e.y][e.x] = o } makeSafePlayerSpawnZone(e, o) { this.setValueAtPosition(this.getPlayerPosition({ y: -1, x: -1 }), t.EMPTY), this.setValueAtPosition(this.getPlayerPosition({ y: -1, x: 0 }), t.EMPTY), this.setValueAtPosition(this.getPlayerPosition({ y: -1, x: 1 }), t.EMPTY), this.setValueAtPosition(this.getPlayerPosition({ y: 0, x: -1 }), t.EMPTY), this.setValueAtPosition(this.getPlayerPosition({ y: 0, x: 1 }), t.EMPTY), this.setValueAtPosition(this.getPlayerPosition(), v.VALUE), this.setValueAtPosition(this.getPlayerPosition({ y: 1, x: 0 }), t.PRESENT), o.setPreviousValue(t.GATE_OUT_CLOSED), o.setPreviousPosition(this.getPlayerPosition()) } getBoard() { return this.board } getScreenPosition() { return this.screenPosition } setScreenPosition(e) { this.screenPosition = e } }; i(h, "instance", null), i(h, "PROBABILITY_UNBREAKABLE_BLOCKS", Math.random() * .4 + .01), i(h, "PROBABILITY_COLLECTABLE_COINS", Math.random() * .2 + .01), i(h, "PROBABILITY_EMPTY_CELLS", Math.random() * .3 + .01); let I = h; const P = class P { constructor(e, o, s) { i(this, "BLINKING_INTERVAL_TIME_MS", 150); i(this, "boardService"); i(this, "playerService"); i(this, "canvas"); i(this, "ctx"); i(this, "CELL_QUANTITY_X"); i(this, "CELL_QUANTITY_Y"); i(this, "CELL_SIZE"); this.canvas = e.canvas, this.ctx = this.canvas.getContext("2d"), this.CELL_QUANTITY_X = e.CELL_QUANTITY_X, this.CELL_QUANTITY_Y = e.CELL_QUANTITY_Y, this.CELL_SIZE = e.CELL_SIZE, this.boardService = o, this.playerService = s } static create(e, o, s) { return P.instance === null && (P.instance = new P(e, o, s)), P.instance } draw() { if (this.playerService.getPlayerHealth() <= 0) { this.drawGameOver(); return } this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.drawArray(this.ctx, this.boardService.getBoard()), this.ctx.strokeRect(0, 0, this.canvas.width, this.canvas.height) } makeBlinkingPlayer(e) { if (e <= 0 || this.playerService.getIsBlinking()) return; this.playerService.setIsBlinking(!0); let o = !1; const s = setInterval(() => { if (o = !o, o) { this.drawPlayerRed(); return } this.drawPlayerNormal() }, this.BLINKING_INTERVAL_TIME_MS); setTimeout(() => { clearInterval(s), this.drawPlayerNormal(), this.playerService.setIsBlinking(!1) }, 3 * this.BLINKING_INTERVAL_TIME_MS + 2 * this.BLINKING_INTERVAL_TIME_MS * (e - 1)) } drawArray(e, o) { for (let s = 0; s < this.CELL_QUANTITY_Y; s++)for (let r = 0; r < this.CELL_QUANTITY_X; r++) { if (s - this.boardService.getScreenPosition().y < 0 || s - this.boardService.getScreenPosition().y >= o.length || r - this.boardService.getScreenPosition().x < 0 || r - this.boardService.getScreenPosition().x >= o[0].length) continue; const n = o[s - this.boardService.getScreenPosition().y][r - this.boardService.getScreenPosition().x]; if (n === t.PLAYER) { e.fillStyle = this.getColor(n), e.fillRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeStyle = "black", e.strokeRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE); continue } if (n === t.UNBREAKABLE) { if (e.fillStyle = this.getColor(n), this.playerService.getPlayerPosition().y > 20) { let a = 255 - this.playerService.getPlayerPosition().y + 10; a <= 205 && (a = 205), e.fillStyle = "rgb(" + a + "," + a + "," + a + ")" } e.fillRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeStyle = "black", e.strokeRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.beginPath(), e.moveTo(r * this.CELL_SIZE, s * this.CELL_SIZE), e.lineTo((r + 1) * this.CELL_SIZE, (s + 1) * this.CELL_SIZE), e.stroke(), e.beginPath(), e.moveTo((r + 1) * this.CELL_SIZE, s * this.CELL_SIZE), e.lineTo(r * this.CELL_SIZE, (s + 1) * this.CELL_SIZE), e.stroke(); continue } if (n === t.COLLECTABLE_COIN) { if (e.fillStyle = this.getColor(n), this.playerService.getPlayerPosition().y > 20) { let a = 255 - this.playerService.getPlayerPosition().y + 10; a <= 205 && (a = 205), e.fillStyle = "rgb(" + a + "," + a + "," + a + ")" } e.fillRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeStyle = "black", e.strokeRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.beginPath(), e.arc((r + .5) * this.CELL_SIZE, (s + .5) * this.CELL_SIZE, this.CELL_SIZE * .45, 0, 2 * Math.PI), e.stroke(); continue } if (n === t.GATE_OUT_CLOSED) { e.fillStyle = this.getColor(n), e.strokeStyle = this.getTextColor(n), e.lineWidth = 6, e.fillRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeRect((r + .1) * this.CELL_SIZE, (s + .1) * this.CELL_SIZE, this.CELL_SIZE * .8, this.CELL_SIZE * .8), e.lineWidth = 1; continue } if (n === t.GATE_OUT_OPENED) { e.fillStyle = this.getColor(n), e.strokeStyle = this.getTextColor(n), e.lineWidth = 6, e.fillRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeRect((r + .1) * this.CELL_SIZE, (s + .1) * this.CELL_SIZE, this.CELL_SIZE * .8, this.CELL_SIZE * .8), e.lineWidth = 1; continue } if (e.fillStyle = this.getColor(n), this.playerService.getPlayerPosition().y > 20 && n === t.EMPTY) { let a = this.playerService.getPlayerPosition().y; a > 80 && (a = 80), e.fillStyle = "rgb(" + a + "," + a + "," + a + ")" } if (this.playerService.getPlayerPosition().y > 20 && n === t.PRESENT) { let a = 255 - this.playerService.getPlayerPosition().y; a <= 195 && (a = 195), e.fillStyle = "rgb(" + a + "," + a + "," + a + ")" } e.fillRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeStyle = "black", e.strokeRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE) } e.fillStyle = this.getColor(t.PLAYER), e.strokeStyle = "black"; for (let s = 0; s < this.CELL_QUANTITY_Y; s++)for (let r = 0; r < this.CELL_QUANTITY_X; r++)s === 0 || s === this.CELL_QUANTITY_Y - 1 ? (e.fillRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE)) : (r === 0 || r === this.CELL_QUANTITY_X - 1) && (e.fillRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), e.strokeRect(r * this.CELL_SIZE, s * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE)); e.fillStyle = this.getColor(t.PLAYER), e.strokeStyle = "black", e.fillRect(0, 0, 2 * this.CELL_SIZE, 2 * this.CELL_SIZE), e.strokeRect(0, 0, 2 * this.CELL_SIZE, 2 * this.CELL_SIZE), e.fillStyle = "white", e.font = Math.floor(this.CELL_SIZE * .3) + "px Arial", e.fillText(`x: ${this.playerService.getPlayerPosition().x} | y: ${this.playerService.getPlayerPosition().y}`, this.CELL_SIZE * .1, this.CELL_SIZE * .3, 2 * this.CELL_SIZE), e.fillText(`blocks: ${this.playerService.getPlayerBlockCount()}`, this.CELL_SIZE * .1, this.CELL_SIZE * .8, 2 * this.CELL_SIZE), e.fillText(`coins: ${this.playerService.getPlayerCoinCount()} / ${v.coinNeed}`, this.CELL_SIZE * .1, this.CELL_SIZE * 1.3, 2 * this.CELL_SIZE), e.fillText(`health: ${this.playerService.getPlayerHealth()} / ${v.healthMax}`, this.CELL_SIZE * .1, this.CELL_SIZE * 1.8, 2 * this.CELL_SIZE), e.fillStyle = this.getColor(t.PLAYER), e.strokeStyle = "black", e.fillRect((this.CELL_QUANTITY_X - 3) * this.CELL_SIZE, 0, 3 * this.CELL_SIZE, this.CELL_SIZE), e.strokeRect((this.CELL_QUANTITY_X - 3) * this.CELL_SIZE, 0, 3 * this.CELL_SIZE, this.CELL_SIZE), e.fillStyle = "white", e.font = Math.floor(this.CELL_SIZE * .3) + "px Arial", e.fillText(`Level : ${this.playerService.getLevelReached()}`, (this.CELL_QUANTITY_X - 3) * this.CELL_SIZE + this.CELL_SIZE * .2, this.CELL_SIZE * .4, 2 * this.CELL_SIZE) } getColor(e) { switch (e) { case t.PRESENT: return "white"; case t.PLAYER: return "grey"; case t.UNBREAKABLE: return "white"; case t.COLLECTABLE_COIN: return "white"; case t.GATE_OUT_CLOSED: return "lightgrey"; case t.GATE_OUT_OPENED: return "grey"; default: return "black" } } getTextColor(e) { switch (e) { case t.PRESENT: return "black"; case t.PLAYER: return "white"; case t.UNBREAKABLE: return "black"; case t.COLLECTABLE_COIN: return "black"; case t.GATE_OUT_CLOSED: return "grey"; case t.GATE_OUT_OPENED: return "white"; default: return "white" } } drawPlayerRed() { this.ctx.fillStyle = "red", this.ctx.strokeStyle = "white", this.ctx.fillRect(Math.floor(this.CELL_QUANTITY_X / 2) * this.CELL_SIZE, Math.floor(this.CELL_QUANTITY_Y / 2) * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), this.ctx.strokeRect(Math.floor(this.CELL_QUANTITY_X / 2) * this.CELL_SIZE, Math.floor(this.CELL_QUANTITY_Y / 2) * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE) } drawPlayerNormal() { this.ctx.fillStyle = this.getColor(t.PLAYER), this.ctx.strokeStyle = "black", this.ctx.fillRect(Math.floor(this.CELL_QUANTITY_X / 2) * this.CELL_SIZE, Math.floor(this.CELL_QUANTITY_Y / 2) * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE), this.ctx.strokeRect(Math.floor(this.CELL_QUANTITY_X / 2) * this.CELL_SIZE, Math.floor(this.CELL_QUANTITY_Y / 2) * this.CELL_SIZE, this.CELL_SIZE, this.CELL_SIZE) } drawGameOver() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.ctx.fillStyle = "black", this.ctx.font = Math.floor(this.CELL_SIZE * 1.5) + "px Arial", this.ctx.fillText("GAME OVER", this.CELL_SIZE * 2, this.CELL_SIZE * 6, this.CELL_SIZE * 11); const e = this.playerService.getLevelReached(); this.ctx.fillText("LevelReached : " + e, this.CELL_SIZE * 1, this.CELL_SIZE * 8, this.CELL_SIZE * 11) } }; i(P, "instance", null); let w = P; class X { constructor(e, o, s, r) { i(this, "canvas"); i(this, "CELL_QUANTITY_X"); i(this, "CELL_QUANTITY_Y"); i(this, "CELL_SIZE"); this.canvas = e, this.CELL_QUANTITY_X = o, this.CELL_QUANTITY_Y = s, this.CELL_SIZE = r } } const C = class C { static mineABlock(e) { Math.random() <= C.CHANCE_TO_GET_BLOCK_FROM_MINING && e.incrementPlayerBlockCount() } static destroyBlockCollectable(e, o) { e.incrementPlayerCoinCount(), e.getPlayerCoinCount() >= v.coinNeed && o.setValueFrom(t.GATE_OUT_OPENED, o.getGateOutPosition()) } static fallingDownRecursiveAction(e, o) { C.actionToDoWhenFallingDown(e), e.emptyDownCount--, e.emptyDownCount <= 0 ? (e.arrowKeysActive = !0, e.emptyDownCount = 1, e.rulesUnbreakableBlock.whenIsAnUnbreakableFallingDownOnPlayer(o), e.drawService.draw()) : setTimeout(() => C.fallingDownRecursiveAction(e, o), 100) } static actionToDoWhenFallingDown(e) { e.boardService.getScreenPosition().y -= 1, e.boardService.getBoard()[e.playerService.getPlayerPosition().y][e.playerService.getPlayerPosition().x] = e.playerService.getPreviousValue(), e.playerService.setPreviousPosition(e.playerService.getPlayerPosition()), e.playerService.getPlayerPosition().y += 1, e.playerService.setPreviousValue(e.boardService.getBoard()[e.playerService.getPlayerPosition().y][e.playerService.getPlayerPosition().x]), e.boardService.getBoard()[e.playerService.getPlayerPosition().y][e.playerService.getPlayerPosition().x] = v.VALUE, e.rulesUnbreakableBlock.whenPlayerSucceedToMoveDown(), e.drawService.draw() } }; i(C, "CHANCE_TO_GET_BLOCK_FROM_MINING", .5); let c = C; const y = class y { constructor(e) { i(this, "eventService"); this.eventService = e } static create(e) { return y.instance === null && (y.instance = new y(e)), y.instance } whenIsNotAbleToMoveUp() { return !this.eventService.arrowKeysActive || this.getPlayerPosY() === 0 || this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] === t.UNBREAKABLE } whenValueIsPresentOnUp() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] === t.PRESENT ? (this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] = t.EMPTY, c.mineABlock(this.eventService.playerService), this.eventService.rulesUnbreakableBlock.whenPlayerSucceedToDigUp(), this.eventService.drawService.draw(), !0) : !1 } whenValueIsCollectableOnUp() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] === t.COLLECTABLE_COIN ? (this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] = t.EMPTY, c.destroyBlockCollectable(this.eventService.playerService, this.eventService.boardService), this.eventService.rulesUnbreakableBlock.whenPlayerSucceedToDigUp(), this.eventService.drawService.draw(), !0) : !1 } whenValueIsEmptyOnUp() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] !== t.EMPTY || this.eventService.playerService.getPreviousValue() === t.GATE_OUT_CLOSED || this.eventService.playerService.getPreviousValue() === t.GATE_OUT_OPENED || this.eventService.playerService.getPlayerBlockCount() <= 0 ? !1 : (this.eventService.playerService.decrementPlayerBlockCount(), this.movePlayerUp(), !0) } whenValueIsGateOutClosedOnUp() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] !== t.GATE_OUT_CLOSED || this.eventService.playerService.getPlayerBlockCount() <= 0 ? !1 : (this.eventService.playerService.decrementPlayerBlockCount(), this.movePlayerUp(), !0) } whenValueIsGateOutOpenedOnUp() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() - 1][this.getPlayerPosX()] !== t.GATE_OUT_OPENED || this.eventService.playerService.getPlayerBlockCount() <= 0 ? !1 : (this.eventService.playerService.decrementPlayerBlockCount(), this.movePlayerUp(), !0) } whenValueOnPlayerPositionIsGateClosed() { return this.eventService.playerService.getPreviousValue() !== t.GATE_OUT_CLOSED ? !1 : (console.log("GateIsClosed"), !0) } whenValueOnPlayerPositionIsGateOpened() { return this.eventService.playerService.getPreviousValue() !== t.GATE_OUT_OPENED ? !1 : (console.log("GateIsOpened go to new level :)"), this.LevelUp(), !0) } getPlayerPosY() { return this.eventService.playerService.getPlayerPosition().y } getPlayerPosX() { return this.eventService.playerService.getPlayerPosition().x } movePlayerUp() { this.eventService.playerService.setPreviousValue(t.PRESENT), this.eventService.boardService.getScreenPosition().y += 1, this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()] = this.eventService.playerService.getPreviousValue(), this.eventService.playerService.setPreviousPosition(this.eventService.playerService.getPlayerPosition()), this.eventService.playerService.getPlayerPosition().y -= 1, this.eventService.playerService.setPreviousValue(this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()]), this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()] = v.VALUE, this.eventService.drawService.draw() } LevelUp() { this.eventService.playerService.decreasePlayerCoinCount(v.coinNeed), v.coinNeed += 5, this.eventService.playerService.increasePlayerLevelReached(), this.eventService.boardService.reCreateBoard(), this.eventService.drawService.draw() } }; i(y, "instance", null); let O = y; const S = class S { constructor(e) { i(this, "eventService"); this.eventService = e } static create(e) { return S.instance === null && (S.instance = new S(e)), S.instance } whenIsNotAbleToMoveDown() { return !this.eventService.arrowKeysActive || this.getPlayerPosY() === this.eventService.boardService.getBoard().length - 1 || this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.UNBREAKABLE } whenValueIsPresentOnDown() { if (this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.PRESENT) { for (this.eventService.arrowKeysActive = !1, this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] = t.EMPTY, c.mineABlock(this.eventService.playerService); this.getPlayerPosY() + this.eventService.emptyDownCount + 1 <= this.eventService.boardService.getBoard().length - 1 && this.eventService.boardService.getBoard()[this.getPlayerPosY() + this.eventService.emptyDownCount + 1][this.getPlayerPosX()] === t.EMPTY;)this.eventService.emptyDownCount++; const e = this.eventService.emptyDownCount; return setTimeout(() => c.fallingDownRecursiveAction(this.eventService, e), 100), !0 } return !1 } whenValueIsCollectableOnDown() { if (this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.COLLECTABLE_COIN) { for (this.eventService.arrowKeysActive = !1, this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] = t.EMPTY, c.destroyBlockCollectable(this.eventService.playerService, this.eventService.boardService); this.getPlayerPosY() + this.eventService.emptyDownCount + 1 <= this.eventService.boardService.getBoard().length - 1 && this.eventService.boardService.getBoard()[this.getPlayerPosY() + this.eventService.emptyDownCount + 1][this.getPlayerPosX()] === t.EMPTY;)this.eventService.emptyDownCount++; const e = this.eventService.emptyDownCount; return setTimeout(() => c.fallingDownRecursiveAction(this.eventService, e), 100), !0 } return !1 } whenValueIsGateOutClosedOnDown() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.GATE_OUT_CLOSED ? (this.movePlayerDown(), !0) : !1 } whenValueIsGateOutOpenedOnDown() { return this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.GATE_OUT_OPENED ? (this.movePlayerDown(), !0) : !1 } whenValueIsEmptyOnDown() { if (this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.EMPTY) { for (this.eventService.arrowKeysActive = !1; this.getPlayerPosY() + this.eventService.emptyDownCount + 1 <= this.eventService.boardService.getBoard().length - 1 && this.eventService.boardService.getBoard()[this.eventService.playerService.getPlayerPosition().y + this.eventService.emptyDownCount + 1][this.eventService.playerService.getPlayerPosition().x] === t.EMPTY;)this.eventService.emptyDownCount++; const e = this.eventService.emptyDownCount; return setTimeout(() => c.fallingDownRecursiveAction(this.eventService, e), 100), !0 } return !1 } getPlayerPosY() { return this.eventService.playerService.getPlayerPosition().y } getPlayerPosX() { return this.eventService.playerService.getPlayerPosition().x } movePlayerDown() { this.eventService.boardService.getScreenPosition().y -= 1, this.eventService.boardService.setValueFrom(this.eventService.playerService.getPreviousValue(), this.eventService.playerService.getPlayerPosition()), this.eventService.playerService.setPreviousPosition(this.eventService.playerService.getPlayerPosition()), this.eventService.playerService.getPlayerPosition().y += 1, this.eventService.playerService.setPreviousValue(this.eventService.boardService.getValueFrom(this.eventService.playerService.getPlayerPosition())), this.eventService.boardService.setValueFrom(t.PLAYER, this.eventService.playerService.getPlayerPosition()), this.eventService.drawService.draw() } }; i(S, "instance", null); let A = S; const E = class E { constructor(e) { i(this, "eventService"); this.eventService = e } static create(e) { return E.instance === null && (E.instance = new E(e)), E.instance } whenIsNotAbleToMoveLeft() { return !this.eventService.arrowKeysActive || this.eventService.playerService.getPlayerPosition().x === 0 || this.getPlayerPosX() > 0 && this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] === t.UNBREAKABLE } whenValueIsPresentOnLeft() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] === t.PRESENT ? (this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] = t.EMPTY, c.mineABlock(this.eventService.playerService), this.eventService.drawService.draw(), !0) : !1 } whenValueIsCollectableOnLeft() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] === t.COLLECTABLE_COIN ? (this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] = t.EMPTY, c.destroyBlockCollectable(this.eventService.playerService, this.eventService.boardService), this.eventService.drawService.draw(), !0) : !1 } whenValueIsGateOutClosedOnLeft() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] === t.GATE_OUT_CLOSED ? (this.movePlayerLeft(), !0) : !1 } whenValueIsGateOutOpenedOnLeft() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] === t.GATE_OUT_OPENED ? (this.movePlayerLeft(), !0) : !1 } whenValueIsEmptyOnLeft() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() - 1] === t.EMPTY ? (this.movePlayerLeft(), this.checkIfPlayerIsFallingDown(), !0) : !1 } getPlayerPosY() { return this.eventService.playerService.getPlayerPosition().y } getPlayerPosX() { return this.eventService.playerService.getPlayerPosition().x } movePlayerLeft() { this.eventService.boardService.getScreenPosition().x += 1, this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()] = this.eventService.playerService.getPreviousValue(), this.eventService.playerService.setPreviousPosition(this.eventService.playerService.getPlayerPosition()), this.eventService.playerService.getPlayerPosition().x -= 1, this.eventService.playerService.setPreviousValue(this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()]), this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()] = v.VALUE, this.eventService.rulesUnbreakableBlock.whenPlayerSucceedToMoveLeft(), this.eventService.drawService.draw() } checkIfPlayerIsFallingDown() { if (!(this.getPlayerPosY() >= this.eventService.boardService.getBoard().length - 1) && this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.EMPTY) { for (this.eventService.arrowKeysActive = !1; this.getPlayerPosY() + this.eventService.emptyDownCount + 1 <= this.eventService.boardService.getBoard().length - 1 && this.eventService.boardService.getBoard()[this.getPlayerPosY() + this.eventService.emptyDownCount + 1][this.getPlayerPosX()] === t.EMPTY;)this.eventService.emptyDownCount++; const e = this.eventService.emptyDownCount; setTimeout(() => c.fallingDownRecursiveAction(this.eventService, e), 100) } } }; i(E, "instance", null); let B = E; const L = class L { constructor(e) { i(this, "eventService"); this.eventService = e } static create(e) { return L.instance === null && (L.instance = new L(e)), L.instance } whenIsNotAbleToMoveRight() { return !this.eventService.arrowKeysActive || this.getPlayerPosX() === this.eventService.boardService.getBoard()[0].length - 1 || this.getPlayerPosX() > 0 && this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] === t.UNBREAKABLE } whenValueIsPresentOnRight() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] === t.PRESENT ? (this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] = t.EMPTY, c.mineABlock(this.eventService.playerService), this.eventService.drawService.draw(), !0) : !1 } whenValueIsCollectableOnRight() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] === t.COLLECTABLE_COIN ? (this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] = t.EMPTY, c.destroyBlockCollectable(this.eventService.playerService, this.eventService.boardService), this.eventService.drawService.draw(), !0) : !1 } whenValueIsGateOutClosedOnRight() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] === t.GATE_OUT_CLOSED ? (this.movePlayerRight(), !0) : !1 } whenValueIsGateOutOpenedOnRight() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] === t.GATE_OUT_OPENED ? (this.movePlayerRight(), !0) : !1 } whenValueIsEmptyOnRight() { return this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX() + 1] === t.EMPTY ? (this.movePlayerRight(), this.checkIfPlayerIsFallingDown(), !0) : !1 } getPlayerPosY() { return this.eventService.playerService.getPlayerPosition().y } getPlayerPosX() { return this.eventService.playerService.getPlayerPosition().x } movePlayerRight() { this.eventService.boardService.getScreenPosition().x -= 1, this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()] = this.eventService.playerService.getPreviousValue(), this.eventService.playerService.setPreviousPosition(this.eventService.playerService.getPlayerPosition()), this.eventService.playerService.getPlayerPosition().x += 1, this.eventService.playerService.setPreviousValue(this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()]), this.eventService.boardService.getBoard()[this.getPlayerPosY()][this.getPlayerPosX()] = v.VALUE, this.eventService.rulesUnbreakableBlock.whenPlayerSucceedToMoveRight(), this.eventService.drawService.draw() } checkIfPlayerIsFallingDown() { if (!(this.getPlayerPosY() >= this.eventService.boardService.getBoard().length - 1) && this.eventService.boardService.getBoard()[this.getPlayerPosY() + 1][this.getPlayerPosX()] === t.EMPTY) { for (this.eventService.arrowKeysActive = !1; this.getPlayerPosY() + this.eventService.emptyDownCount + 1 <= this.eventService.boardService.getBoard().length - 1 && this.eventService.boardService.getBoard()[this.getPlayerPosY() + this.eventService.emptyDownCount + 1][this.getPlayerPosX()] === t.EMPTY;)this.eventService.emptyDownCount++; const e = this.eventService.emptyDownCount; setTimeout(() => c.fallingDownRecursiveAction(this.eventService, e), 100) } } }; i(L, "instance", null); let T = L; class p { constructor(e) { i(this, "audio"); i(this, "loaded", !1); this.audio = new Audio(e), this.audio.preload = "auto", this.audio.addEventListener("canplaythrough", () => { this.loaded = !0 }), this.audio.addEventListener("error", o => { console.error("Error loading sound:", o) }) } setSrc(e) { this.loaded = !1, this.audio.pause(), this.audio.currentTime = 0, this.audio.src = e, this.audio.load() } async play() { try { await this.audio.play() } catch (e) { console.error("Error playing sound:", e) } } pause() { this.audio.pause() } stop() { this.audio.pause(), this.audio.currentTime = 0 } setVolume(e) { this.audio.volume = Math.max(0, Math.min(1, e)) } setLoop(e) { this.audio.loop = e } isLoaded() { return this.loaded } getDuration() { return this.audio.duration || 0 } getCurrentTime() { return this.audio.currentTime } } const d = class d { constructor(e) { i(this, "eventService"); i(this, "playerPreviousPosition", { x: 0, y: 0 }); i(this, "blockUpponPlayerPreviousPosition", { x: 0, y: 0 }); i(this, "playerPosition", { x: 0, y: 0 }); i(this, "blockUpponPlayerPosition", { x: 0, y: 0 }); i(this, "soundAou", new p("resources/common/sound/aou.MP3")); this.eventService = e } static create(e) { return d.instance === null && (d.instance = new d(e)), d.instance } whenPlayerSucceedToMoveLeft() { this.IsUnbreakableBlockOnTopOfPreviousPlayerPosition() && this.unbreakableBlockGoesOnPreviousPlayerPosition() } whenPlayerSucceedToMoveRight() { this.IsUnbreakableBlockOnTopOfPreviousPlayerPosition() && this.unbreakableBlockGoesOnPreviousPlayerPosition() } whenPlayerSucceedToMoveDown() { this.IsUnbreakableBlockOnTopOfPreviousPlayerPosition() && (this.soundAou.stop(), this.soundAou.play(), this.unbreakableBlockGoesOnPreviousPlayerPosition()) } whenIsAnUnbreakableFallingDownOnPlayer(e) { this.IsUnbreakableBlockOnTopOfActualPlayerPosition() && (this.soundAou.stop(), this.soundAou.play(), this.eventService.playerService.decreasePlayerHealth(e, this.eventService.drawService) === !1 && this.gameOver()) } whenPlayerSucceedToDigUp() { if (this.playerPosition.y <= 1) return; const e = { x: this.playerPosition.x, y: this.playerPosition.y - 2 }; this.IsUnbreakableBlockOnPosition(e) && (this.soundAou.stop(), this.soundAou.play(), this.unbreakableBlockGoesDownFromPosition(e), this.eventService.playerService.decreasePlayerHealth(1, this.eventService.drawService) === !1 && this.gameOver()) } IsUnbreakableBlockOnTopOfPreviousPlayerPosition() { return this.playerPreviousPosition = this.eventService.playerService.getPreviousPosition(), this.playerPreviousPosition.y < 1 ? !1 : (this.blockUpponPlayerPreviousPosition = { x: this.playerPreviousPosition.x, y: this.playerPreviousPosition.y - 1 }, this.eventService.boardService.getValueFrom(this.blockUpponPlayerPreviousPosition) === t.UNBREAKABLE) } IsUnbreakableBlockOnTopOfActualPlayerPosition() { return this.playerPosition = this.eventService.playerService.getPlayerPosition(), this.playerPosition.y < 1 ? !1 : (this.blockUpponPlayerPosition = { x: this.playerPosition.x, y: this.playerPosition.y - 1 }, this.eventService.boardService.getValueFrom(this.blockUpponPlayerPosition) === t.UNBREAKABLE) } unbreakableBlockGoesOnPreviousPlayerPosition() { this.eventService.boardService.setValueFrom(t.EMPTY, this.blockUpponPlayerPreviousPosition), this.eventService.boardService.setValueFrom(t.UNBREAKABLE, this.playerPreviousPosition) } IsUnbreakableBlockOnPosition(e) { return this.eventService.boardService.getValueFrom(e) === t.UNBREAKABLE } unbreakableBlockGoesDownFromPosition(e) { e.y >= this.eventService.boardService.getBoard().length - 1 || (this.eventService.boardService.setValueFrom(t.EMPTY, e), this.eventService.boardService.setValueFrom(t.UNBREAKABLE, e, { x: 0, y: 1 })) } gameOver() { this.eventService.arrowKeysActive = !1, console.log("GAME OVER") } }; i(d, "instance", null); let _ = d; const g = class g { constructor(e, o, s, r) { i(this, "boardService"); i(this, "playerService"); i(this, "drawService"); i(this, "rulesOnArrowUp", O.create(this)); i(this, "rulesOnArrowDown", A.create(this)); i(this, "rulesOnArrowLeft", B.create(this)); i(this, "rulesOnArrowRight", T.create(this)); i(this, "rulesUnbreakableBlock", _.create(this)); i(this, "arrowKeysActive", !0); i(this, "emptyDownCount", 1); i(this, "window"); i(this, "keyBoardEventListener"); i(this, "soundBip", new p("resources/common/sound/bip.MP3")); i(this, "soundBop", new p("resources/game-mining/sound/bop.MP3")); i(this, "soundDig", new p("resources/game-mining/sound/dig.MP3")); i(this, "soundDududili", new p("resources/game-mining/sound/dududili.MP3")); i(this, "soundYop", new p("resources/common/sound/yop.MP3")); this.window = e, this.drawService = o, this.boardService = s, this.playerService = r, this.keyBoardEventListener = n => { this.handleKeyBoardEvent(n) } } static create(e, o, s, r) { return g.instance === null && (g.instance = new g(e, o, s, r)), g.instance } addEventListenerToWindow() { window.addEventListener("keydown", this.keyBoardEventListener) } removeEventListenerFromWindow() { window.removeEventListener("keydown", this.keyBoardEventListener) } handleKeyBoardEvent(e) { e.key === "ArrowUp" ? this.actionsOnArrowUp(e) : e.key === "ArrowDown" ? this.actionsOnArrowDown(e) : e.key === "ArrowLeft" ? this.actionsOnArrowLeft(e) : e.key === "ArrowRight" && this.actionsOnArrowRight(e) } actionsOnArrowUp(e) { switch (e.preventDefault(), !0) { case this.rulesOnArrowUp.whenValueOnPlayerPositionIsGateClosed(): this.soundBop.stop(), this.soundBop.play(); break; case this.rulesOnArrowUp.whenValueOnPlayerPositionIsGateOpened(): this.soundDududili.stop(), this.soundDududili.play(); break; case this.rulesOnArrowUp.whenIsNotAbleToMoveUp(): this.soundBop.stop(), this.soundBop.play(); break; case this.rulesOnArrowUp.whenValueIsPresentOnUp(): this.soundDig.stop(), this.soundDig.play(); break; case this.rulesOnArrowUp.whenValueIsCollectableOnUp(): this.soundDududili.stop(), this.soundDududili.play(); break; case this.rulesOnArrowUp.whenValueIsGateOutClosedOnUp(): this.soundBip.stop(), this.soundBip.play(); break; case this.rulesOnArrowUp.whenValueIsGateOutOpenedOnUp(): this.soundBip.stop(), this.soundBip.play(); break; case this.rulesOnArrowUp.whenValueIsEmptyOnUp(): this.soundYop.stop(), this.soundYop.play(); break } } actionsOnArrowDown(e) { switch (e.preventDefault(), !0) { case this.rulesOnArrowDown.whenIsNotAbleToMoveDown(): this.soundBop.stop(), this.soundBop.play(); break; case this.rulesOnArrowDown.whenValueIsPresentOnDown(): this.soundDig.stop(), this.soundDig.play(); break; case this.rulesOnArrowDown.whenValueIsCollectableOnDown(): this.soundDududili.stop(), this.soundDududili.play(); break; case this.rulesOnArrowDown.whenValueIsGateOutClosedOnDown(): this.soundBip.stop(), this.soundBip.play(); break; case this.rulesOnArrowDown.whenValueIsGateOutOpenedOnDown(): this.soundBip.stop(), this.soundBip.play(); break; case this.rulesOnArrowDown.whenValueIsEmptyOnDown(): break } } actionsOnArrowLeft(e) { switch (e.preventDefault(), !0) { case this.rulesOnArrowLeft.whenIsNotAbleToMoveLeft(): this.soundBop.stop(), this.soundBop.play(); break; case this.rulesOnArrowLeft.whenValueIsPresentOnLeft(): this.soundDig.stop(), this.soundDig.play(); break; case this.rulesOnArrowLeft.whenValueIsCollectableOnLeft(): this.soundDududili.stop(), this.soundDududili.play(); break; case this.rulesOnArrowLeft.whenValueIsGateOutClosedOnLeft(): this.soundBip.stop(), this.soundBip.play(); break; case this.rulesOnArrowLeft.whenValueIsGateOutOpenedOnLeft(): this.soundBip.stop(), this.soundBip.play(); break; case this.rulesOnArrowLeft.whenValueIsEmptyOnLeft(): this.soundBip.stop(), this.soundBip.play(); break } } actionsOnArrowRight(e) { switch (e.preventDefault(), !0) { case this.rulesOnArrowRight.whenIsNotAbleToMoveRight(): this.soundBop.stop(), this.soundBop.play(); break; case this.rulesOnArrowRight.whenValueIsPresentOnRight(): this.soundDig.stop(), this.soundDig.play(); break; case this.rulesOnArrowRight.whenValueIsCollectableOnRight(): this.soundDududili.stop(), this.soundDududili.play(); break; case this.rulesOnArrowRight.whenValueIsGateOutClosedOnRight(): this.soundBip.stop(), this.soundBip.play(); break; case this.rulesOnArrowRight.whenValueIsGateOutOpenedOnRight(): this.soundBip.stop(), this.soundBip.play(); break; case this.rulesOnArrowRight.whenValueIsEmptyOnRight(): this.soundBip.stop(), this.soundBip.play(); break } } }; i(g, "instance", null); let b = g; const k = 15, m = 11, Y = v.create({ x: Math.floor(k / 2), y: Math.floor(m / 2) }), G = 32, K = 32, Z = I.create(G, K, Y), U = 50, F = U * k, x = U * m, Q = M("app", "MiningGame", F, x), H = new X(Q, k, m, U), R = w.create(H, Z, Y), W = b.create(window, R, Z, Y); W.addEventListenerToWindow(); R.draw();
  </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vite + TS</title>
  <style>
    html,
    body {
      height: 100vh;
      margin: 0;
      padding: 0;
    }

    .top-div {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 20vh;
      width: 100%;
    }

    .canvas-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 70vh;
      width: 90%;
      margin: 0 auto;
    }
  </style>

</head>

<body style="background-color: darkgrey; text-align: center;">
  <div class="top-div">
    <div style="display: flex; flex-direction: column; align-items: center;">
      <a href="./index.html">Go to IndexPage --&gt; </a>
      <h1 style="padding: 0%; margin: 0%; margin-top: 1%;">ShadockGameV0.1</h1>
    </div>
  </div>


  <div class="canvas-container" id="app"></div>


  <script>var p = Object.defineProperty; var f = (r, t, i) => t in r ? p(r, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : r[t] = i; var a = (r, t, i) => f(r, typeof t != "symbol" ? t + "" : t, i); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const e of document.querySelectorAll('link[rel="modulepreload"]')) s(e); new MutationObserver(e => { for (const o of e) if (o.type === "childList") for (const c of o.addedNodes) c.tagName === "LINK" && c.rel === "modulepreload" && s(c) }).observe(document, { childList: !0, subtree: !0 }); function i(e) { const o = {}; return e.integrity && (o.integrity = e.integrity), e.referrerPolicy && (o.referrerPolicy = e.referrerPolicy), e.crossOrigin === "use-credentials" ? o.credentials = "include" : e.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function s(e) { if (e.ep) return; e.ep = !0; const o = i(e); fetch(e.href, o) } })(); class x { constructor(t) { a(this, "canvas"); a(this, "context"); this.canvas = t, this.context = t.getContext("2d") } clear() { this.context.clearRect(0, 0, this.canvas.width, this.canvas.height) } drawRect(t, i, s, e, o) { this.context.fillStyle = o, this.context.fillRect(t, i, s, e) } drawStrokeRect(t, i, s, e, o) { this.context.strokeStyle = o, this.context.strokeRect(t, i, s, e) } drawRectWithRotation(t, i, s, e, o, c) { this.context.save(), this.context.translate(t + s / 2, i + e / 2), this.context.rotate(o), this.context.fillStyle = c, this.context.fillRect(-s / 2, -e / 2, s, e), this.context.restore() } drawCircle(t, i, s, e) { this.context.fillStyle = e, this.context.beginPath(), this.context.arc(t, i, s, 0, Math.PI * 2), this.context.fill(), this.context.closePath() } drawStrokeCircle(t, i, s, e) { this.context.strokeStyle = e, this.context.beginPath(), this.context.arc(t, i, s, 0, Math.PI * 2), this.context.stroke(), this.context.closePath() } drawText(t, i, s, e) { this.context.fillStyle = e, this.context.font = "16px Arial", this.context.fillText(s, t, i) } drawCenterText(t) { const i = this.context.measureText(t).width, s = (this.canvas.width - i) / 2, e = this.canvas.height / 2; this.drawText(s, e, t, "black") } drawImage(t, i, s, e, o) { this.context.drawImage(t, i, s, e, o) } drawImageWithRotation(t, i, s, e, o, c) { this.context.save(), this.context.translate(i + e / 2, s + o / 2), this.context.rotate(c), this.context.drawImage(t, -e / 2, -o / 2, e, o), this.context.restore() } } class u { constructor(t) { a(this, "audio"); a(this, "_isLoaded", !1); this.audio = new Audio(t), this.audio.preload = "auto", this.audio.addEventListener("canplaythrough", () => { this._isLoaded = !0 }) } get isLoaded() { return this._isLoaded } async play() { this._isLoaded || await new Promise(t => { this.audio.addEventListener("canplaythrough", t, { once: !0 }) }); try { await this.audio.play() } catch (t) { console.error("Error playing sound:", t) } } stop() { this.audio.pause(), this.audio.currentTime = 0 } } window.onload = () => { var h; let r = document.getElementById("app"); if (!r || !(r instanceof HTMLDivElement)) return; let t = document.createElement("canvas"); t.id = "canvas", t.className = "canvas-container", r.appendChild(t); const i = new x(t); let s = "touch to activate", e = new u("./resources/common/sound/yop.mp3"); const o = new b; let c = 0; function n() { setTimeout(() => { t.width = window.innerWidth * .9, t.height = window.innerHeight * .7, l(i, t, s, o) }, 100) } (h = screen.orientation) == null || h.addEventListener("change", () => { n() }), n(), m() ? (t.ontouchstart = () => { if (c !== 2) { if (c === 0) { c = 1; return } e = new u("./resources/common/sound/yop.mp3"), c = 2 } e.stop(), e.play(), d(o), s = "ontouchstart" }, t.ontouchend = () => { s = "ontouchend" }) : t.onclick = () => { e.stop(), e.play(), d(o), s = "onclick" }, setInterval(() => { l(i, t, s, o) }, 50) }; function l(r, t, i, s) { r.clear(), r.drawStrokeRect(0, 0, t.width, t.height, "black"), s.render(r, t), r.drawCenterText(i) } function m() { return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) } function d(r) { r.jump() } class b { constructor() { a(this, "square", { x: .45, y: .9, w: .1, h: .1, color: "black" }); a(this, "squareState", "onGround"); a(this, "jumpMaxValue", .22); a(this, "jumpStep", .012); a(this, "jumpValue", 0); a(this, "initialYPosBeforeJump", this.square.y); a(this, "cube", { x: .95, y: .95, w: .05, h: .05, color: "green" }); a(this, "cubeState", "movingLeft"); a(this, "cubeSpeedX", .01); a(this, "cubeSpeedXMax", .2); a(this, "score", 0); setInterval(() => { this.squareAction(), this.cubeAction(), this.interactionBetweenSquareAndCube() }, 50) } squareAction() { this.squareState === "jumping" ? (this.jumpValue < this.jumpMaxValue ? this.jumpValue += this.jumpStep : (this.jumpValue = this.jumpMaxValue, this.squareState = "fallingDown"), this.updatePosition()) : this.squareState === "fallingDown" && (this.jumpValue > this.jumpStep ? this.jumpValue -= this.jumpStep : (this.jumpValue = 0, this.squareState = "onGround"), this.updatePosition()) } updatePosition() { this.square.y = this.initialYPosBeforeJump - this.jumpValue } jump() { this.squareState === "onGround" && (this.initialYPosBeforeJump = this.square.y, this.squareState = "jumping") } cubeAction() { this.cubeState === "movingLeft" ? this.cube.x <= 0 ? (this.cubeState = "movingRight", this.score += 1, this.cubeSpeedX < this.cubeSpeedXMax && (this.cubeSpeedX += .001)) : this.cube.x -= this.cubeSpeedX : this.cubeState === "movingRight" && (this.cube.x > .99 - this.cube.w ? (this.cubeState = "movingLeft", this.score += 1, this.cubeSpeedX < this.cubeSpeedXMax && (this.cubeSpeedX += .001)) : this.cube.x += this.cubeSpeedX) } interactionBetweenSquareAndCube() { this.square.color === "black" && this.square.x < this.cube.x + this.cube.w && this.square.x + this.square.w > this.cube.x && this.square.y < this.cube.y + this.cube.h && this.square.y + this.square.h > this.cube.y ? (this.square.color = "red", this.score -= 1) : this.square.color !== "black" && (this.square.x > this.cube.x + this.cube.w || this.square.x + this.square.w < this.cube.x || this.square.y > this.cube.y + this.cube.h || this.square.y + this.square.h < this.cube.y) && (this.square.color = "black") } render(t, i) { t.drawRect(this.square.x * i.width, this.square.y * i.height, this.square.w * i.width, this.square.h * i.height, this.square.color), t.drawRect(this.cube.x * i.width, this.cube.y * i.height, this.cube.w * i.width, this.cube.h * i.height, this.cube.color), t.drawText(20, 20, "score: " + this.score, "white") } }
  </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vite + TS</title>
  <style>
    html,
    body {
      height: 100vh;
      margin: 0;
      padding: 0;
    }

    .top-div {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 20vh;
      width: 100%;
    }

    .canvas-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 70vh;
      width: 90%;
      margin: 0 auto;
    }
  </style>

</head>

<body style="background-color: darkgrey; text-align: center;">
  <div class="top-div">
    <div style="display: flex; flex-direction: column; align-items: center;">
      <a href="./index.html">Go to IndexPage --&gt; </a>
      <h1 style="padding: 0%; margin: 0%; margin-top: 1%;">ShadockGameV0.1</h1>
    </div>
  </div>


  <div class="canvas-container" id="app"></div>


  <script>var p = Object.defineProperty; var f = (a, t, e) => t in a ? p(a, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : a[t] = e; var r = (a, t, e) => f(a, typeof t != "symbol" ? t + "" : t, e); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) s(i); new MutationObserver(i => { for (const o of i) if (o.type === "childList") for (const n of o.addedNodes) n.tagName === "LINK" && n.rel === "modulepreload" && s(n) }).observe(document, { childList: !0, subtree: !0 }); function e(i) { const o = {}; return i.integrity && (o.integrity = i.integrity), i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? o.credentials = "include" : i.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function s(i) { if (i.ep) return; i.ep = !0; const o = e(i); fetch(i.href, o) } })(); class m { constructor(t) { r(this, "canvas"); r(this, "context"); this.canvas = t, this.context = t.getContext("2d") } clear() { this.context.clearRect(0, 0, this.canvas.width, this.canvas.height) } drawRect(t, e, s, i, o) { this.context.fillStyle = o, this.context.fillRect(t, e, s, i) } drawStrokeRect(t, e, s, i, o) { this.context.strokeStyle = o, this.context.strokeRect(t, e, s, i) } drawRectWithRotation(t, e, s, i, o, n) { this.context.save(), this.context.translate(t + s / 2, e + i / 2), this.context.rotate(o), this.context.fillStyle = n, this.context.fillRect(-s / 2, -i / 2, s, i), this.context.restore() } drawCircle(t, e, s, i) { this.context.fillStyle = i, this.context.beginPath(), this.context.arc(t, e, s, 0, Math.PI * 2), this.context.fill(), this.context.closePath() } drawStrokeCircle(t, e, s, i) { this.context.strokeStyle = i, this.context.beginPath(), this.context.arc(t, e, s, 0, Math.PI * 2), this.context.stroke(), this.context.closePath() } drawText(t, e, s, i) { this.context.fillStyle = i, this.context.font = "16px Arial", this.context.fillText(s, t, e) } drawCenterText(t) { const e = this.context.measureText(t).width, s = (this.canvas.width - e) / 2, i = this.canvas.height / 2; this.drawText(s, i, t, "black") } drawImage(t, e, s, i, o) { this.context.drawImage(t, e, s, i, o) } drawImageWithRotation(t, e, s, i, o, n) { this.context.save(), this.context.translate(e + i / 2, s + o / 2), this.context.rotate(n), this.context.drawImage(t, -i / 2, -o / 2, i, o), this.context.restore() } } class h { constructor(t) { r(this, "audio"); r(this, "loaded", !1); r(this, "loadError", !1); r(this, "userInteracted", !1); r(this, "pendingPlay", !1); this.audio = new Audio(t), this.audio.preload = "auto", this.audio.muted = !1, this.audio.volume = 1, this.audio.addEventListener("canplaythrough", () => { this.loaded = !0, this.loadError = !1, this.pendingPlay && this.userInteracted && (this.pendingPlay = !1, this.play()) }), this.audio.addEventListener("error", e => { console.error("Error loading sound:", t, e), this.loadError = !0, this.loaded = !1, this.pendingPlay = !1 }), this.audio.addEventListener("loadstart", () => { this.loadError = !1 }), this.setupUserInteractionListener() } setupUserInteractionListener() { const t = () => { this.userInteracted = !0; try { const e = window.AudioContext || window.webkitAudioContext; e && new e().resume() } catch { } document.removeEventListener("touchstart", t), document.removeEventListener("click", t), document.removeEventListener("keydown", t) }; document.addEventListener("touchstart", t, { once: !0 }), document.addEventListener("click", t, { once: !0 }), document.addEventListener("keydown", t, { once: !0 }) } setSrc(t) { this.loaded = !1, this.loadError = !1, this.pendingPlay = !1, this.audio.pause(), this.audio.currentTime = 0, this.audio.src = t, this.audio.load() } async play() { if (!this.loadError) { if (!this.loaded) { this.pendingPlay = !0; return } if (!this.userInteracted) { this.pendingPlay = !0; return } try { this.audio.muted = !1, await this.audio.play(), this.pendingPlay = !1 } catch (t) { t instanceof DOMException && t.name === "NotAllowedError" ? this.pendingPlay = !0 : (console.error("Error playing sound:", t), this.loadError = !0) } } } pause() { this.loadError || (this.audio.pause(), this.pendingPlay = !1) } stop() { this.loadError || (this.audio.pause(), this.audio.currentTime = 0, this.pendingPlay = !1) } setVolume(t) { this.audio.volume = Math.max(0, Math.min(1, t)) } setLoop(t) { this.audio.loop = t } isLoaded() { return this.loaded && !this.loadError } hasError() { return this.loadError } canPlay() { return this.loaded && !this.loadError && this.userInteracted } getDuration() { return this.loadError ? 0 : this.audio.duration || 0 } getCurrentTime() { return this.loadError ? 0 : this.audio.currentTime } enableAudio() { this.userInteracted = !0, this.pendingPlay && this.loaded && !this.loadError && this.play() } } let d = !1; window.onload = () => { var c; let a = document.getElementById("app"); if (!a || !(a instanceof HTMLDivElement)) return; let t = document.createElement("canvas"); t.id = "canvas", t.className = "canvas-container", a.appendChild(t); const e = new m(t); let s = "touch to see"; const i = new y; function o() { setTimeout(() => { t.width = window.innerWidth * .9, t.height = window.innerHeight * .7, u(e, t, s, i) }, 100) } (c = screen.orientation) == null || c.addEventListener("change", () => { o() }), o(); async function n() { d || (await i.initializeAudio(), d = !0) } x() ? (t.ontouchstart = async () => { s = "ontouchstart", await n(), u(e, t, s, i) }, t.ontouchend = () => { l(i), s = "ontouchend", u(e, t, s, i) }) : t.onclick = async () => { await n(), l(i), s = "onclick", u(e, t, s, i) }, setInterval(() => { u(e, t, s, i) }, 50) }; function u(a, t, e, s) { a.clear(), a.drawStrokeRect(0, 0, t.width, t.height, "black"), s.render(a, t), a.drawCenterText(e) } function x() { return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) } function l(a) { a.jump() } class y { constructor() { r(this, "square", { x: .45, y: .9, w: .1, h: .1, color: "black" }); r(this, "squareState", "onGround"); r(this, "jumpMaxValue", .22); r(this, "jumpStep", .012); r(this, "jumpValue", 0); r(this, "initialYPosBeforeJump", this.square.y); r(this, "cube", { x: .95, y: .95, w: .05, h: .05, color: "green" }); r(this, "cubeState", "movingLeft"); r(this, "cubeSpeedX", .01); r(this, "cubeSpeedXMax", .2); r(this, "score", 0); r(this, "soundAou"); r(this, "soundBip"); r(this, "soundYop"); this.soundAou = new h("./resources/common/sound/aou.mp3"), this.soundBip = new h("./resources/common/sound/bip.mp3"), this.soundYop = new h("./resources/common/sound/yop.mp3"), setInterval(() => { this.squareAction(), this.cubeAction(), this.interactionBetweenSquareAndCube() }, 50) } async initializeAudio() { try { await this.soundAou.play(), this.soundAou.stop(), await this.soundBip.play(), this.soundBip.stop(), await this.soundYop.play(), this.soundYop.stop() } catch (t) { console.log("Audio initialization failed:", t) } } squareAction() { this.squareState === "jumping" ? (this.jumpValue < this.jumpMaxValue ? this.jumpValue += this.jumpStep : (this.jumpValue = this.jumpMaxValue, this.squareState = "fallingDown"), this.updatePosition()) : this.squareState === "fallingDown" && (this.jumpValue > this.jumpStep ? this.jumpValue -= this.jumpStep : (this.jumpValue = 0, this.squareState = "onGround"), this.updatePosition()) } updatePosition() { this.square.y = this.initialYPosBeforeJump - this.jumpValue } jump() { this.squareState === "onGround" && (this.soundYop.stop(), this.soundYop.play(), this.initialYPosBeforeJump = this.square.y, this.squareState = "jumping") } cubeAction() { this.cubeState === "movingLeft" ? this.cube.x <= 0 ? (this.soundBip.stop(), this.soundBip.play(), this.cubeState = "movingRight", this.score += 1, this.cubeSpeedX < this.cubeSpeedXMax && (this.cubeSpeedX += .001)) : this.cube.x -= this.cubeSpeedX : this.cubeState === "movingRight" && (this.cube.x > .99 - this.cube.w ? (this.soundBip.stop(), this.soundBip.play(), this.cubeState = "movingLeft", this.score += 1, this.cubeSpeedX < this.cubeSpeedXMax && (this.cubeSpeedX += .001)) : this.cube.x += this.cubeSpeedX) } interactionBetweenSquareAndCube() { this.square.color === "black" && this.square.x < this.cube.x + this.cube.w && this.square.x + this.square.w > this.cube.x && this.square.y < this.cube.y + this.cube.h && this.square.y + this.square.h > this.cube.y ? (this.soundAou.stop(), this.soundAou.play(), this.square.color = "red", this.score -= 1) : this.square.color !== "black" && (this.square.x > this.cube.x + this.cube.w || this.square.x + this.square.w < this.cube.x || this.square.y > this.cube.y + this.cube.h || this.square.y + this.square.h < this.cube.y) && (this.square.color = "black") } render(t, e) { t.drawRect(this.square.x * e.width, this.square.y * e.height, this.square.w * e.width, this.square.h * e.height, this.square.color), t.drawRect(this.cube.x * e.width, this.cube.y * e.height, this.cube.w * e.width, this.cube.h * e.height, this.cube.color), t.drawText(20, 20, "score: " + this.score, "white") } }
  </script>
</body>

</html>
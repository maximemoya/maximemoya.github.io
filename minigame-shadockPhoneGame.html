<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vite + TS</title>
  <style>
    html,
    body {
      height: 100vh;
      margin: 0;
      padding: 0;
    }

    .top-div {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 20vh;
      width: 100%;
    }

    .canvas-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 70vh;
      width: 90%;
      margin: 0 auto;
    }
  </style>

</head>

<body style="background-color: darkgrey; text-align: center;">
  <div class="top-div">
    <div style="display: flex; flex-direction: column; align-items: center;">
      <a href="./index.html">Go to IndexPage --&gt; </a>
      <h1 style="padding: 0%; margin: 0%; margin-top: 1%;">ShadockGameV0.1</h1>
    </div>
  </div>


  <div class="canvas-container" id="app"></div>


  <script>var l = Object.defineProperty; var p = (r, t, e) => t in r ? l(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e; var a = (r, t, e) => p(r, typeof t != "symbol" ? t + "" : t, e); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) s(i); new MutationObserver(i => { for (const o of i) if (o.type === "childList") for (const n of o.addedNodes) n.tagName === "LINK" && n.rel === "modulepreload" && s(n) }).observe(document, { childList: !0, subtree: !0 }); function e(i) { const o = {}; return i.integrity && (o.integrity = i.integrity), i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? o.credentials = "include" : i.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function s(i) { if (i.ep) return; i.ep = !0; const o = e(i); fetch(i.href, o) } })(); class f { constructor(t) { a(this, "canvas"); a(this, "context"); this.canvas = t, this.context = t.getContext("2d") } clear() { this.context.clearRect(0, 0, this.canvas.width, this.canvas.height) } drawRect(t, e, s, i, o) { this.context.fillStyle = o, this.context.fillRect(t, e, s, i) } drawStrokeRect(t, e, s, i, o) { this.context.strokeStyle = o, this.context.strokeRect(t, e, s, i) } drawRectWithRotation(t, e, s, i, o, n) { this.context.save(), this.context.translate(t + s / 2, e + i / 2), this.context.rotate(o), this.context.fillStyle = n, this.context.fillRect(-s / 2, -i / 2, s, i), this.context.restore() } drawCircle(t, e, s, i) { this.context.fillStyle = i, this.context.beginPath(), this.context.arc(t, e, s, 0, Math.PI * 2), this.context.fill(), this.context.closePath() } drawStrokeCircle(t, e, s, i) { this.context.strokeStyle = i, this.context.beginPath(), this.context.arc(t, e, s, 0, Math.PI * 2), this.context.stroke(), this.context.closePath() } drawText(t, e, s, i) { this.context.fillStyle = i, this.context.font = "16px Arial", this.context.fillText(s, t, e) } drawCenterText(t) { const e = this.context.measureText(t).width, s = (this.canvas.width - e) / 2, i = this.canvas.height / 2; this.drawText(s, i, t, "black") } drawImage(t, e, s, i, o) { this.context.drawImage(t, e, s, i, o) } drawImageWithRotation(t, e, s, i, o, n) { this.context.save(), this.context.translate(e + i / 2, s + o / 2), this.context.rotate(n), this.context.drawImage(t, -i / 2, -o / 2, i, o), this.context.restore() } } class c { constructor(t) { a(this, "audio"); a(this, "loaded", !1); a(this, "loadError", !1); a(this, "userInteracted", !1); a(this, "pendingPlay", !1); this.audio = new Audio(t), this.audio.preload = "auto", this.audio.muted = !1, this.audio.volume = 1, this.audio.addEventListener("canplaythrough", () => { this.loaded = !0, this.loadError = !1, this.pendingPlay && this.userInteracted && (this.pendingPlay = !1, this.play()) }), this.audio.addEventListener("error", e => { console.error("Error loading sound:", t, e), this.loadError = !0, this.loaded = !1, this.pendingPlay = !1 }), this.audio.addEventListener("loadstart", () => { this.loadError = !1 }), this.setupUserInteractionListener() } setupUserInteractionListener() { const t = () => { this.userInteracted = !0; try { const e = window.AudioContext || window.webkitAudioContext; e && new e().resume() } catch { } document.removeEventListener("touchstart", t), document.removeEventListener("click", t), document.removeEventListener("keydown", t) }; document.addEventListener("touchstart", t, { once: !0 }), document.addEventListener("click", t, { once: !0 }), document.addEventListener("keydown", t, { once: !0 }) } setSrc(t) { this.loaded = !1, this.loadError = !1, this.pendingPlay = !1, this.audio.pause(), this.audio.currentTime = 0, this.audio.src = t, this.audio.load() } async play() { if (!this.loadError) { if (!this.loaded) { this.pendingPlay = !0; return } if (!this.userInteracted) { this.pendingPlay = !0; return } try { this.audio.muted = !1, await this.audio.play(), this.pendingPlay = !1 } catch (t) { t instanceof DOMException && t.name === "NotAllowedError" ? this.pendingPlay = !0 : (console.error("Error playing sound:", t), this.loadError = !0) } } } pause() { this.loadError || (this.audio.pause(), this.pendingPlay = !1) } stop() { this.loadError || (this.audio.pause(), this.audio.currentTime = 0, this.pendingPlay = !1) } setVolume(t) { this.audio.volume = Math.max(0, Math.min(1, t)) } setLoop(t) { this.audio.loop = t } isLoaded() { return this.loaded && !this.loadError } hasError() { return this.loadError } canPlay() { return this.loaded && !this.loadError && this.userInteracted } getDuration() { return this.loadError ? 0 : this.audio.duration || 0 } getCurrentTime() { return this.loadError ? 0 : this.audio.currentTime } async enableAudio() { try { this.userInteracted = !0; const t = window.AudioContext || window.webkitAudioContext; if (t) { const e = new t; e.state === "suspended" && await e.resume() } try { const e = new Audio; e.volume = 0, e.muted = !0; const s = e.play(); s && await s.catch(() => { }) } catch { } return this.pendingPlay && this.loaded && !this.loadError && (this.pendingPlay = !1, await this.play()), !0 } catch (t) { return console.warn("Failed to enable audio:", t), this.userInteracted = !0, !1 } } } window.onload = () => { var n; let r = document.getElementById("app"); if (!r || !(r instanceof HTMLDivElement)) return; let t = document.createElement("canvas"); t.id = "canvas", t.className = "canvas-container", r.appendChild(t); const e = new f(t); let s = "touch to see"; const i = new x; function o() { setTimeout(() => { t.width = window.innerWidth * .9, t.height = window.innerHeight * .7, h(e, t, s, i) }, 100) } (n = screen.orientation) == null || n.addEventListener("change", () => { o() }), o(), m() ? (t.ontouchstart = () => { const u = new c("./resources/common/sound/yop.mp3"); u.enableAudio(), u.stop(), u.play(), d(i), s = "ontouchstart" }, t.ontouchend = () => { s = "ontouchend" }) : t.onclick = () => { const u = new c("./resources/common/sound/yop.mp3"); u.enableAudio(), u.stop(), u.play(), d(i), s = "onclick" }, setInterval(() => { h(e, t, s, i) }, 50) }; function h(r, t, e, s) { r.clear(), r.drawStrokeRect(0, 0, t.width, t.height, "black"), s.render(r, t), r.drawCenterText(e) } function m() { return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) } function d(r) { r.jump() } class x { constructor() { a(this, "square", { x: .45, y: .9, w: .1, h: .1, color: "black" }); a(this, "squareState", "onGround"); a(this, "jumpMaxValue", .22); a(this, "jumpStep", .012); a(this, "jumpValue", 0); a(this, "initialYPosBeforeJump", this.square.y); a(this, "cube", { x: .95, y: .95, w: .05, h: .05, color: "green" }); a(this, "cubeState", "movingLeft"); a(this, "cubeSpeedX", .01); a(this, "cubeSpeedXMax", .2); a(this, "score", 0); setInterval(() => { this.squareAction(), this.cubeAction(), this.interactionBetweenSquareAndCube() }, 50) } squareAction() { this.squareState === "jumping" ? (this.jumpValue < this.jumpMaxValue ? this.jumpValue += this.jumpStep : (this.jumpValue = this.jumpMaxValue, this.squareState = "fallingDown"), this.updatePosition()) : this.squareState === "fallingDown" && (this.jumpValue > this.jumpStep ? this.jumpValue -= this.jumpStep : (this.jumpValue = 0, this.squareState = "onGround"), this.updatePosition()) } updatePosition() { this.square.y = this.initialYPosBeforeJump - this.jumpValue } jump() { this.squareState === "onGround" && (this.initialYPosBeforeJump = this.square.y, this.squareState = "jumping") } cubeAction() { this.cubeState === "movingLeft" ? this.cube.x <= 0 ? (this.cubeState = "movingRight", this.score += 1, this.cubeSpeedX < this.cubeSpeedXMax && (this.cubeSpeedX += .001)) : this.cube.x -= this.cubeSpeedX : this.cubeState === "movingRight" && (this.cube.x > .99 - this.cube.w ? (this.cubeState = "movingLeft", this.score += 1, this.cubeSpeedX < this.cubeSpeedXMax && (this.cubeSpeedX += .001)) : this.cube.x += this.cubeSpeedX) } interactionBetweenSquareAndCube() { this.square.color === "black" && this.square.x < this.cube.x + this.cube.w && this.square.x + this.square.w > this.cube.x && this.square.y < this.cube.y + this.cube.h && this.square.y + this.square.h > this.cube.y ? (this.square.color = "red", this.score -= 1) : this.square.color !== "black" && (this.square.x > this.cube.x + this.cube.w || this.square.x + this.square.w < this.cube.x || this.square.y > this.cube.y + this.cube.h || this.square.y + this.square.h < this.cube.y) && (this.square.color = "black") } render(t, e) { t.drawRect(this.square.x * e.width, this.square.y * e.height, this.square.w * e.width, this.square.h * e.height, this.square.color), t.drawRect(this.cube.x * e.width, this.cube.y * e.height, this.cube.w * e.width, this.cube.h * e.height, this.cube.color), t.drawText(20, 20, "score: " + this.score, "white") } }
  </script>
</body>

</html>
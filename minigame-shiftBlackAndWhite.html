<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vite + TS</title>
  <style>
    .canvas-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 80vh;
    }
  </style>

</head>

<a href="./index.html">Go to IndexPage --> </a>

<body style="background-color: darkgrey; text-align: center;">
  <div id="app"></div>


  <script>var k = Object.defineProperty; var g = (l, a, e) => a in l ? k(l, a, { enumerable: !0, configurable: !0, writable: !0, value: e }) : l[a] = e; var s = (l, a, e) => g(l, typeof a != "symbol" ? a + "" : a, e); (function () { const a = document.createElement("link").relList; if (a && a.supports && a.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) t(r); new MutationObserver(r => { for (const o of r) if (o.type === "childList") for (const i of o.addedNodes) i.tagName === "LINK" && i.rel === "modulepreload" && t(i) }).observe(document, { childList: !0, subtree: !0 }); function e(r) { const o = {}; return r.integrity && (o.integrity = r.integrity), r.referrerPolicy && (o.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? o.credentials = "include" : r.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function t(r) { if (r.ep) return; r.ep = !0; const o = e(r); fetch(r.href, o) } })(); class T { constructor() { s(this, "backgroundColor", "white") } } class O { constructor(a, e) { s(this, "render"); s(this, "player"); s(this, "arrayOfTheMap", []); s(this, "playerPosition", { x: 0, y: 0 }); this.render = a, this.player = e; for (let t = 0; t < 20; t++) { const r = []; for (let o = 0; o < 20; o++)r.push(new T); this.arrayOfTheMap.push(r) } this.arrayOfTheMap[12][12].backgroundColor = "grey", this.arrayOfTheMap[0][3].backgroundColor = "black", this.arrayOfTheMap[0][4].backgroundColor = "black", this.arrayOfTheMap[0][5].backgroundColor = "black", this.arrayOfTheMap[0][7].backgroundColor = "black", this.arrayOfTheMap[0][8].backgroundColor = "black", this.arrayOfTheMap[0][9].backgroundColor = "black", this.arrayOfTheMap[1][4].backgroundColor = "black", this.arrayOfTheMap[1][5].backgroundColor = "black", this.arrayOfTheMap[1][6].backgroundColor = "black", this.arrayOfTheMap[1][7].backgroundColor = "black", this.arrayOfTheMap[1][8].backgroundColor = "black", this.arrayOfTheMap[2][5].backgroundColor = "black", this.arrayOfTheMap[2][6].backgroundColor = "black", this.arrayOfTheMap[2][7].backgroundColor = "black", this.arrayOfTheMap[3][6].backgroundColor = "black", this.arrayOfTheMap[4][6].backgroundColor = "black", this.arrayOfTheMap[5][6].backgroundColor = "black", this.arrayOfTheMap[6][6].backgroundColor = "black", this.arrayOfTheMap[7][6].backgroundColor = "black", this.arrayOfTheMap[8][6].backgroundColor = "black", this.arrayOfTheMap[9][6].backgroundColor = "black", this.arrayOfTheMap[10][6].backgroundColor = "black", this.arrayOfTheMap[9][7].backgroundColor = "black", this.arrayOfTheMap[10][7].backgroundColor = "black", this.arrayOfTheMap[10][8].backgroundColor = "black", this.arrayOfTheMap[10][9].backgroundColor = "black", this.arrayOfTheMap[10][10].backgroundColor = "black", this.arrayOfTheMap[11][7].backgroundColor = "black", this.arrayOfTheMap[11][6].backgroundColor = "black", this.arrayOfTheMap[12][6].backgroundColor = "black", this.arrayOfTheMap[13][6].backgroundColor = "black", this.arrayOfTheMap[14][6].backgroundColor = "black", this.arrayOfTheMap[15][6].backgroundColor = "black", this.arrayOfTheMap[16][6].backgroundColor = "black", this.arrayOfTheMap[17][6].backgroundColor = "black", this.arrayOfTheMap[18][6].backgroundColor = "black", this.arrayOfTheMap[19][6].backgroundColor = "black", this.arrayOfTheMap[15][7].backgroundColor = "black", this.arrayOfTheMap[16][7].backgroundColor = "black", this.arrayOfTheMap[17][7].backgroundColor = "black", this.arrayOfTheMap[18][7].backgroundColor = "black", this.arrayOfTheMap[16][8].backgroundColor = "black", this.arrayOfTheMap[17][8].backgroundColor = "black", this.arrayOfTheMap[16][9].backgroundColor = "black", this.arrayOfTheMap[17][9].backgroundColor = "black", this.arrayOfTheMap[16][10].backgroundColor = "black", this.arrayOfTheMap[17][10].backgroundColor = "black", this.putPlayerOn(this.playerPosition) } draw(a, e) { let t = 0, r = 0; const o = 1; for (let i = 0; i < this.arrayOfTheMap.length; i++)for (let c = 0; c < this.arrayOfTheMap[i].length; c++) { const d = this.arrayOfTheMap[i][c]; t = (a - this.arrayOfTheMap[i].length) / this.arrayOfTheMap[i].length, r = (e - this.arrayOfTheMap.length) / this.arrayOfTheMap.length, this.render.drawRect(c * (t + o), i * (r + o), t, r, d.backgroundColor) } this.player.colorAvailableToWalk !== this.arrayOfTheMap[this.playerPosition.y][this.playerPosition.x].backgroundColor ? this.render.drawStrokeCircle(this.playerPosition.x * t + this.playerPosition.x * o + t * .5, this.playerPosition.y * r + this.playerPosition.y * o + r * .5, t * .2, this.player.getPlayerColor() === "white" ? "black" : "white") : this.render.drawCircle(this.playerPosition.x * t + this.playerPosition.x * o + t * .5, this.playerPosition.y * r + this.playerPosition.y * o + r * .5, t * .2, this.player.getPlayerColor()) } putPlayerOn(a) { return this.checkPlayerCanGoOn(a) ? (this.playerPosition = { ...a }, !0) : !1 } checkPlayerCanGoOn(a) { return !(a.y < 0 || a.y >= this.arrayOfTheMap.length || a.x < 0 || a.x >= this.arrayOfTheMap[0].length || this.arrayOfTheMap[a.y][a.x].backgroundColor !== this.player.colorAvailableToWalk) } movePlayerRight() { return this.putPlayerOn({ x: this.playerPosition.x + 1, y: this.playerPosition.y }) } movePlayerLeft() { return this.putPlayerOn({ x: this.playerPosition.x - 1, y: this.playerPosition.y }) } movePlayerUp() { return this.putPlayerOn({ x: this.playerPosition.x, y: this.playerPosition.y - 1 }) } movePlayerDown() { return this.putPlayerOn({ x: this.playerPosition.x, y: this.playerPosition.y + 1 }) } shiftPlayer() { this.player.shift() } } class M { constructor() { s(this, "colorAvailableToWalk", "white") } shift() { this.colorAvailableToWalk = this.colorAvailableToWalk === "white" ? "black" : "white" } getPlayerColor() { return this.colorAvailableToWalk === "white" ? "black" : "white" } } class C { constructor(a) { s(this, "canvas"); s(this, "context"); this.canvas = a, this.context = a.getContext("2d") } clear() { this.context.clearRect(0, 0, this.canvas.width, this.canvas.height) } drawRect(a, e, t, r, o) { this.context.fillStyle = o, this.context.fillRect(a, e, t, r) } drawStrokeRect(a, e, t, r, o) { this.context.strokeStyle = o, this.context.strokeRect(a, e, t, r) } drawRectWithRotation(a, e, t, r, o, i) { this.context.save(), this.context.translate(a + t / 2, e + r / 2), this.context.rotate(o), this.context.fillStyle = i, this.context.fillRect(-t / 2, -r / 2, t, r), this.context.restore() } drawCircle(a, e, t, r) { this.context.fillStyle = r, this.context.beginPath(), this.context.arc(a, e, t, 0, Math.PI * 2), this.context.fill(), this.context.closePath() } drawStrokeCircle(a, e, t, r) { this.context.strokeStyle = r, this.context.beginPath(), this.context.arc(a, e, t, 0, Math.PI * 2), this.context.stroke(), this.context.closePath() } drawText(a, e, t, r) { this.context.fillStyle = r, this.context.font = "16px Arial", this.context.fillText(t, a, e) } drawCenterText(a) { const e = this.context.measureText(a).width, t = (this.canvas.width - e) / 2, r = this.canvas.height / 2; this.drawText(t, r, a, "black") } drawImage(a, e, t, r, o) { this.context.drawImage(a, e, t, r, o) } drawImageWithRotation(a, e, t, r, o, i) { this.context.save(), this.context.translate(e + r / 2, t + o / 2), this.context.rotate(i), this.context.drawImage(a, -r / 2, -o / 2, r, o), this.context.restore() } } class f { constructor(a) { s(this, "audio"); s(this, "loaded", !1); this.audio = new Audio(a), this.audio.preload = "auto", this.audio.addEventListener("canplaythrough", () => { this.loaded = !0 }), this.audio.addEventListener("error", e => { console.error("Error loading sound:", e) }) } setSrc(a) { this.loaded = !1, this.audio.pause(), this.audio.currentTime = 0, this.audio.src = a, this.audio.load() } async play() { try { await this.audio.play() } catch (a) { console.error("Error playing sound:", a) } } pause() { this.audio.pause() } stop() { this.audio.pause(), this.audio.currentTime = 0 } setVolume(a) { this.audio.volume = Math.max(0, Math.min(1, a)) } setLoop(a) { this.audio.loop = a } isLoaded() { return this.loaded } getDuration() { return this.audio.duration || 0 } getCurrentTime() { return this.audio.currentTime } } let u = document.createElement("div"); u.id = "div-screen"; document.body.appendChild(u); const b = document.createElement("h1"); b.innerText = "Game Canvas Shift"; u.appendChild(b); let n = document.createElement("canvas"); n.id = "canvas"; n.width = 800; n.height = 600; u.appendChild(n); window.onload = () => { const l = new C(n), a = new M, e = new O(l, a), t = new f("resources/gameShiftBlackAndWhite/sound/move-gloup.MP3"), r = new f("resources/gameShiftBlackAndWhite/sound/move-pas-gloup.MP3"), o = new f("resources/gameShiftBlackAndWhite/sound/shift-bib.MP3"); let i = !1, c = !1, d = !1, y = !1; window.onkeydown = h => { h.code === "ArrowLeft" ? (i || (e.movePlayerLeft() ? (t.stop(), t.play()) : (r.stop(), r.play())), i = !0) : h.code === "ArrowRight" ? (c || (e.movePlayerRight() ? (t.stop(), t.play()) : (r.stop(), r.play())), c = !0) : h.code === "ArrowUp" ? (d || (e.movePlayerUp() ? (t.stop(), t.play()) : (r.stop(), r.play())), d = !0) : h.code === "ArrowDown" ? (y || (e.movePlayerDown() ? (t.stop(), t.play()) : (r.stop(), r.play())), y = !0) : h.key === "Shift" && (o.stop(), o.play(), e.shiftPlayer()) }, window.onkeyup = h => { h.code === "ArrowLeft" ? i = !1 : h.code === "ArrowRight" ? c = !1 : h.code === "ArrowUp" ? d = !1 : h.code === "ArrowDown" && (y = !1) }, setInterval(() => { x(l, e) }, 100) }; function x(l, a) { l.clear(), l.drawStrokeRect(0, 0, n.width, n.height, "black"), a.draw(n.width, n.height) }
  </script>
</body>

</html>